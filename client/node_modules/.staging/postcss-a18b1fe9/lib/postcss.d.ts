import * as mozilla from 'source-map';

/**
 * @param plugins Can also be included with the Processor#use method.
 * @returns A processor that will apply plugins as CSS processors.
 */
declare function postcss(plugins?: postcss.AcceptedPlugin[]): postcss.Processor;
declare function postcss(...plugins: postcss.AcceptedPlugin[]): postcss.Processor;
declare namespace postcss {
    type AcceptedPlugin = Plugin<any> | Transformer | {
        postcss: TransformCallback | Processor;
    } | Processor;
    /**
     * Creates a PostCSS plugin with a standard API.
     * @param name Plugin name. Same as in name property in package.json. It will
     * be saved in plugin.postcssPlugin property.
     * @param initializer Will receive plugin options and should return functions
     * to modify nodes in input CSS.
     */
    function plugin<T>(name: string, initializer: PluginInitializer<T>): Plugin<T>;
    interface Plugin<T> extends Transformer {
        (opts?: T): Transformer;
        postcss: Transformer;
        process: (css: string | {
            toString(): string;
        } | Result, opts?: any) => LazyResult;
    }
    interface Transformer extends TransformCallback {
        postcssPlugin?: string;
        postcssVersion?: string;
    }
    interface TransformCallback {
        /**
         * @returns Asynchronous plugins should return a promise.
         */
        (root: Root, result?: Result): void | Function | any;
    }
    interface PluginInitializer<T> {
        (pluginOptions?: T): Transformer;
    }
    /**
     * Contains helpers for working with vendor prefixes.
     */
    export namespace vendor {
        /**
         * @returns The vendor prefix extracted from the input string.
         */
        function prefix(prop: string): string;
        /**
         * @returns The input string stripped of its vendor prefix.
         */
        function unprefixed(prop: string): string;
    }
    export class Stringifier {
        builder: Stringifier.Builder;
        constructor(builder?: Stringifier.Builder);
        stringify(node: Node, semicolon?: boolean): void;
        root(node: any): void;
        comment(node: any): void;
        decl(node: any, semicolon: any): void;
        rule(node: any): void;
        atrule(node: any, semicolon: any): void;
        body(node: any): void;
        block(node: any, start: any): void;
        raw(node: Node, own: string, detect?: string): any;
        rawSemicolon(root: any): any;
        rawEmptyBody(root: any): any;
        rawIndent(root: any): any;
        rawBeforeComment(root: any, node: any): any;
        rawBeforeDecl(root: any, node: any): any;
        rawBeforeRule(root: any): any;
        rawBeforeClose(root: any): any;
        rawBeforeOpen(root: any): any;
        rawColon(root: any): any;
        beforeAfter(node: any, detect: any): any;
        rawValue(node: any, prop: any): any;
    }
    export namespace Stringifier {
        interface Builder {
            (str: string, node?: Node, str2?: string): void;
        }
    }
    /**
     * Default function to convert a node tree into a CSS string.
     */
    function stringify(node: Node, builder: Stringifier.Builder): void;
    /**
     * Parses source CSS.
     * @param css The CSS to parse.
     * @param options
     * @returns {} A new Root node, which contains the source CSS nodes.
     */
    function parse(css: string | {
        toString(): string;
    } | LazyResult | Result, options?: {
        from?: string;
        map?: postcss.SourceMapOptions;
    }): Root;
    /**
     * Contains helpers for safely splitting lists of CSS values, preserving
     * parentheses and quotes.
     */
    export namespace list {
        /**
         * Safely splits space-separated values (such as those for background,
         * border-radius and other shorthand properties).
         */
        function space(str: string): string[];
        /**
         * Safely splits comma-separated values (such as those for transition-* and
         * background  properties).
         */
        function comma(str: string): string[];
    }
    /**
     * Creates a new Comment node.
     * @param defaults Properties for the new Comment node.
     * @returns The new node.
     */
    function comment(defaults?: CommentNewProps): Comment;
    /**
     * Creates a new AtRule node.
     * @param defaults Properties for the new AtRule node.
     * @returns The new node.
     */
    function atRule(defaults?: AtRuleNewProps): AtRule;
    /**
     * Creates a new Declaration node.
     * @param defaults Properties for the new Declaration node.
     * @returns The new node.
     */
    function decl(defaults?: DeclarationNewProps): Declaration;
    /**
     * Creates a new Rule node.
     * @param defaults Properties for the new Rule node.
     * @returns The new node.
     */
    function rule(defaults?: RuleNewProps): Rule;
    /**
     * Creates a new Root node.
     * @param defaults Properties for the new Root node.
     * @returns The new node.
     */
    function root(defaults?: object): Root;
    interface SourceMapOptions {
        