(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable2"] = factory(require("react"));
	else
		root["ReactBootstrapTable2"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(10)();
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  SORT_ASC: 'asc',
  SORT_DESC: 'desc',
  ROW_SELECT_SINGLE: 'radio',
  ROW_SELECT_MULTIPLE: 'checkbox',
  ROW_SELECT_DISABLED: 'ROW_SELECT_DISABLED',
  CHECKBOX_STATUS_CHECKED: 'checked',
  CHECKBOX_STATUS_INDETERMINATE: 'indeterminate',
  CHECKBOX_STATUS_UNCHECKED: 'unchecked'
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _underscore = __webpack_require__(18);

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function splitNested(str) {
  return [str].join('.').replace(/\[/g, '.').replace(/\]/g, '').split('.');
} /* eslint no-empty: 0 */
/* eslint no-param-reassign: 0 */
/* eslint prefer-rest-params: 0 */


function get(target, field) {
  var pathArray = splitNested(field);
  var result = void 0;
  try {
    result = pathArray.reduce(function (curr, path) {
      return curr[path];
    }, target);
  } catch (e) {}
  return result;
}

function set(target, field, value) {
  var safe = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var pathArray = splitNested(field);
  var level = 0;
  pathArray.reduce(function (a, b) {
    level += 1;
    if (typeof a[b] === 'undefined') {
      if (!safe) throw new Error(a + '.' + b + ' is undefined');
      a[b] = {};
      return a[b];
    }

    if (level === pathArray.length) {
      a[b] = value;
      return value;
    }
    return a[b];
  }, target);
}

function isEmptyObject(obj) {
  if (!_underscore2.default.isObject(obj)) return false;

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i += 1) {
    if (hasOwnProperty.call(obj, keys[i])) return false;
  }

  return true;
}

function isDefined(value) {
  return typeof value !== 'undefined' && value !== null;
}

function sleep(fn, ms) {
  return setTimeout(function () {
    return fn();
  }, ms);
}

function debounce(func, wait, immediate) {
  var _this = this,
      _arguments = arguments;

  var timeout = void 0;

  return function () {
    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(_this, _arguments);
      }
    };

    var callNow = immediate && !timeout;

    clearTimeout(timeout);
    timeout = setTimeout(later, wait || 0);

    if (callNow) {
      func.apply(_this, _arguments);
    }
  };
}

exports.default = Object.assign(_underscore2.default, { get: get, set: set, isDefined: isDefined, isEmptyObject: isEmptyObject, sleep: sleep, debounce: debounce });

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BootstrapContext = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BootstrapContext = exports.BootstrapContext = _react2.default.createContext({
  bootstrap4: false
});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var matchRow = exports.matchRow = function matchRow(keyField, id) {
  return function (row) {
    return row[keyField] === id;
  };
};

var getRowByRowId = exports.getRowByRowId = function getRowByRowId(data, keyField, id) {
  return data.find(matchRow(keyField, id));
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedRows = exports.unSelectableKeys = exports.selectableKeys = exports.getSelectionSummary = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getSelectionSummary = exports.getSelectionSummary = function getSelectionSummary(data, keyField) {
  var selected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var allRowsSelected = true;
  var allRowsNotSelected = true;

  var rowKeys = data.map(function (d) {
    return d[keyField];
  });

  var _loop = function _loop(i) {
    var curr = rowKeys[i];
    if (typeof selected.find(function (x) {
      return x === curr;
    }) === 'undefined') {
      allRowsSelected = false;
    } else {
      allRowsNotSelected = false;
    }
  };

  for (var i = 0; i < rowKeys.length; i += 1) {
    _loop(i);
  }
  return {
    allRowsSelected: allRowsSelected,
    allRowsNotSelected: allRowsNotSelected
  };
};

var selectableKeys = exports.selectableKeys = function selectableKeys(data, keyField) {
  var skips = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (skips.length === 0) {
    return data.map(function (row) {
      return _utils2.default.get(row, keyField);
    });
  }
  return data.filter(function (row) {
    return !skips.includes(_utils2.default.get(row, keyField));
  }).map(function (row) {
    return _utils2.default.get(row, keyField);
  });
};

var unSelectableKeys = exports.unSelectableKeys = function unSelectableKeys(selected) {
  var skips = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (skips.length === 0) {
    return [];
  }
  return selected.filter(function (x) {
    return skips.includes(x);
  });
};

var getSelectedRows = exports.getSelectedRows = function getSelectedRows(data, keyField, selected) {
  return selected.map(function (k) {
    return (0, _rows.getRowByRowId)(data, keyField, k);
  });
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bootstrapTable = __webpack_require__(9);

var _bootstrapTable2 = _interopRequireDefault(_bootstrapTable);

var _contexts = __webpack_require__(33);

var _contexts2 = _interopRequireDefault(_contexts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _contexts2.default)(_bootstrapTable2.default);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _header = __webpack_require__(14);

var _header2 = _interopRequireDefault(_header);

var _caption = __webpack_require__(21);

var _caption2 = _interopRequireDefault(_caption);

var _body = __webpack_require__(22);

var _body2 = _interopRequireDefault(_body);

var _propsResolver = __webpack_require__(30);

var _propsResolver2 = _interopRequireDefault(_propsResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _selection = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint arrow-body-style: 0 */

var BootstrapTable = function (_PropsBaseResolver) {
  _inherits(BootstrapTable, _PropsBaseResolver);

  function BootstrapTable(props) {
    _classCallCheck(this, BootstrapTable);

    var _this = _possibleConstructorReturn(this, (BootstrapTable.__proto__ || Object.getPrototypeOf(BootstrapTable)).call(this, props));

    _this.getData = function () {
      return _this.props.data;
    };

    _this.validateProps();
    if (props.registerExposedAPI) {
      var getData = function getData() {
        return _this.getData();
      };
      props.registerExposedAPI(getData);
    }
    return _this;
  }

  // Exposed APIs


  _createClass(BootstrapTable, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          loading = _props.loading,
          overlay = _props.overlay;

      if (overlay) {
        var LoadingOverlay = overlay(loading);
        return _react2.default.createElement(
          LoadingOverlay,
          null,
          this.renderTable()
        );
      }
      return this.renderTable();
    }
  }, {
    key: 'renderTable',
    value: function renderTable() {
      var _props2 = this.props,
          data = _props2.data,
          columns = _props2.columns,
          keyField = _props2.keyField,
          id = _props2.id,
          classes = _props2.classes,
          striped = _props2.striped,
          hover = _props2.hover,
          bordered = _props2.bordered,
          condensed = _props2.condensed,
          noDataIndication = _props2.noDataIndication,
          caption = _props2.caption,
          rowStyle = _props2.rowStyle,
          rowClasses = _props2.rowClasses,
          wrapperClasses = _props2.wrapperClasses,
          rowEvents = _props2.rowEvents,
          selected = _props2.selected;


      var tableWrapperClass = (0, _classnames2.default)('react-bootstrap-table', wrapperClasses);

      var tableClass = (0, _classnames2.default)('table', {
        'table-striped': striped,
        'table-hover': hover,
        'table-bordered': bordered,
        'table-condensed': condensed
      }, classes);

      var cellSelectionInfo = this.resolveSelectRowProps({
        onRowSelect: this.props.onRowSelect
      });

      var _getSelectionSummary = (0, _selection.getSelectionSummary)(data, keyField, selected),
          allRowsSelected = _getSelectionSummary.allRowsSelected,
          allRowsNotSelected = _getSelectionSummary.allRowsNotSelected;

      var headerCellSelectionInfo = this.resolveSelectRowPropsForHeader({
        onAllRowsSelect: this.props.onAllRowsSelect,
        selected: selected,
        allRowsSelected: allRowsSelected,
        allRowsNotSelected: allRowsNotSelected
      });

      var tableCaption = caption && _react2.default.createElement(
        _caption2.default,
        null,
        caption
      );
      var expandRow = this.resolveExpandRowProps();

      return _react2.default.createElement(
        'div',
        { className: tableWrapperClass },
        _react2.default.createElement(
          'table',
          { id: id, className: tableClass },
          tableCaption,
          _react2.default.createElement(_header2.default, {
            columns: columns,
            className: this.props.headerClasses,
            sortField: this.props.sortField,
            sortOrder: this.props.sortOrder,
            onSort: this.props.onSort,
            onFilter: this.props.onFilter,
            onExternalFilter: this.props.onExternalFilter,
            selectRow: headerCellSelectionInfo,
            expandRow: expandRow
          }),
          _react2.default.createElement(_body2.default, {
            data: data,
            keyField: keyField,
            columns: columns,
            isEmpty: this.isEmpty(),
            visibleColumnSize: this.visibleColumnSize(),
            noDataIndication: noDataIndication,
            cellEdit: this.props.cellEdit || {},
            selectRow: cellSelectionInfo,
            selectedRowKeys: selected,
            expandRow: expandRow,
            rowStyle: rowStyle,
            rowClasses: rowClasses,
            rowEvents: rowEvents
          })
        )
      );
    }
  }]);

  return BootstrapTable;
}((0, _propsResolver2.default)(_react.Component));

BootstrapTable.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  bootstrap4: _propTypes2.default.bool,
  remote: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.shape({
    pagination: _propTypes2.default.bool
  })]),
  noDataIndication: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  striped: _propTypes2.default.bool,
  bordered: _propTypes2.default.bool,
  hover: _propTypes2.default.bool,
  id: _propTypes2.default.string,
  classes: _propTypes2.default.string,
  wrapperClasses: _propTypes2.default.string,
  condensed: _propTypes2.default.bool,
  caption: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string]),
  pagination: _propTypes2.default.object,
  filter: _propTypes2.default.object,
  cellEdit: _propTypes2.default.object,
  selectRow: _propTypes2.default.shape({
    mode: _propTypes2.default.oneOf([_const2.default.ROW_SELECT_SINGLE, _const2.default.ROW_SELECT_MULTIPLE]).isRequired,
    clickToSelect: _propTypes2.default.bool,
    clickToEdit: _propTypes2.default.bool,
    onSelect: _propTypes2.default.func,
    onSelectAll: _propTypes2.default.func,
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    nonSelectable: _propTypes2.default.array,
    bgColor: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    hideSelectColumn: _propTypes2.default.bool,
    selectionRenderer: _propTypes2.default.func,
    selectionHeaderRenderer: _propTypes2.default.func
  }),
  onRowSelect: _propTypes2.default.func,
  onAllRowsSelect: _propTypes2.default.func,
  expandRow: _propTypes2.default.shape({
    renderer: _propTypes2.default.func.isRequired,
    expanded: _propTypes2.default.array,
    onExpand: _propTypes2.default.func,
    onExpandAll: _propTypes2.default.func,
    nonExpandable: _propTypes2.default.array,
    showExpandColumn: _propTypes2.default.bool,
    expandColumnRenderer: _propTypes2.default.func,
    expandHeaderColumnRenderer: _propTypes2.default.func
  }),
  onRowExpand: _propTypes2.default.func,
  onAllRowExpand: _propTypes2.default.func,
  isAnyExpands: _propTypes2.default.bool,
  rowStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
  rowEvents: _propTypes2.default.object,
  rowClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  headerClasses: _propTypes2.default.string,
  defaultSorted: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    order: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]).isRequired
  })),
  defaultSortDirection: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]),
  overlay: _propTypes2.default.func,
  onTableChange: _propTypes2.default.func,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func,
  onExternalFilter: _propTypes2.default.func,
  // Inject from toolkit
  search: _propTypes2.default.shape({
    searchText: _propTypes2.default.string,
    searchContext: _propTypes2.default.func
  }),
  setDependencyModules: _propTypes2.default.func
};

BootstrapTable.defaultProps = {
  bootstrap4: false,
  remote: false,
  striped: false,
  bordered: true,
  hover: false,
  condensed: false,
  noDataIndication: null
};

exports.default = BootstrapTable;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(11);
var invariant = __webpack_require__(12);
var ReactPropTypesSecret = __webpack_require__(13);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _headerCell = __webpack_require__(15);

var _headerCell2 = _interopRequireDefault(_headerCell);

var _selectionHeaderCell = __webpack_require__(19);

var _selectionHeaderCell2 = _interopRequireDefault(_selectionHeaderCell);

var _expandHeaderCell = __webpack_require__(20);

var _expandHeaderCell2 = _interopRequireDefault(_expandHeaderCell);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint react/require-default-props: 0 */
var Header = function Header(props) {
  var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;
  var className = props.className,
      columns = props.columns,
      onSort = props.onSort,
      onFilter = props.onFilter,
      sortField = props.sortField,
      sortOrder = props.sortOrder,
      selectRow = props.selectRow,
      onExternalFilter = props.onExternalFilter,
      expandRow = props.expandRow,
      bootstrap4 = props.bootstrap4;


  return _react2.default.createElement(
    'thead',
    null,
    _react2.default.createElement(
      'tr',
      { className: className },
      expandRow && expandRow.showExpandColumn ? _react2.default.createElement(_expandHeaderCell2.default, {
        onAllRowExpand: expandRow.onAllRowExpand,
        anyExpands: expandRow.isAnyExpands,
        renderer: expandRow.expandHeaderColumnRenderer
      }) : null,
      selectRow.mode !== ROW_SELECT_DISABLED && !selectRow.hideSelectColumn ? _react2.default.createElement(_selectionHeaderCell2.default, selectRow) : null,
      columns.map(function (column, i) {
        if (!column.hidden) {
          var currSort = column.dataField === sortField;
          var isLastSorting = column.dataField === sortField;

          return _react2.default.createElement(_headerCell2.default, {
            index: i,
            bootstrap4: bootstrap4,
            key: column.dataField,
            column: column,
            onSort: onSort,
            sorting: currSort,
            onFilter: onFilter,
            onExternalFilter: onExternalFilter,
            sortOrder: sortOrder,
            isLastSorting: isLastSorting
          });
        }
        return false;
      })
    )
  );
};

Header.propTypes = {
  columns: _propTypes2.default.array.isRequired,
  onSort: _propTypes2.default.func,
  onFilter: _propTypes2.default.func,
  sortField: _propTypes2.default.string,
  sortOrder: _propTypes2.default.string,
  selectRow: _propTypes2.default.object,
  onExternalFilter: _propTypes2.default.func,
  className: _propTypes2.default.string,
  expandRow: _propTypes2.default.object,
  bootstrap4: _propTypes2.default.bool
};

exports.default = Header;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/require-default-props: 0 */


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _symbol = __webpack_require__(16);

var _symbol2 = _interopRequireDefault(_symbol);

var _caret = __webpack_require__(17);

var _caret2 = _interopRequireDefault(_caret);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HeaderCell = function HeaderCell(props) {
  var column = props.column,
      index = props.index,
      onSort = props.onSort,
      sorting = props.sorting,
      sortOrder = props.sortOrder,
      isLastSorting = props.isLastSorting,
      onFilter = props.onFilter,
      onExternalFilter = props.onExternalFilter;
  var text = column.text,
      sort = column.sort,
      filter = column.filter,
      filterRenderer = column.filterRenderer,
      headerTitle = column.headerTitle,
      headerAlign = column.headerAlign,
      headerFormatter = column.headerFormatter,
      headerEvents = column.headerEvents,
      headerClasses = column.headerClasses,
      headerStyle = column.headerStyle,
      headerAttrs = column.headerAttrs,
      headerSortingClasses = column.headerSortingClasses,
      headerSortingStyle = column.headerSortingStyle;


  var cellAttrs = _extends({}, _utils2.default.isFunction(headerAttrs) ? headerAttrs(column, index) : headerAttrs, headerEvents);

  var sortSymbol = void 0;
  var filterElm = void 0;
  var cellStyle = {};
  var cellClasses = _utils2.default.isFunction(headerClasses) ? headerClasses(column, index) : headerClasses;

  if (headerStyle) {
    cellStyle = _utils2.default.isFunction(headerStyle) ? headerStyle(column, index) : headerStyle;
  }

  if (headerTitle) {
    cellAttrs.title = _utils2.default.isFunction(headerTitle) ? headerTitle(column, index) : text;
  }

  if (headerAlign) {
    cellStyle.textAlign = _utils2.default.isFunction(headerAlign) ? headerAlign(column, index) : headerAlign;
  }

  if (sort) {
    var customClick = cellAttrs.onClick;
    cellAttrs.onClick = function (e) {
      onSort(column);
      if (_utils2.default.isFunction(customClick)) customClick(e);
    };
    cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, 'sortable');

    if (sorting) {
      sortSymbol = _react2.default.createElement(_caret2.default, { order: sortOrder });

      // append customized classes or style if table was sorting based on the current column.
      cellClasses = (0, _classnames2.default)(cellClasses, _utils2.default.isFunction(headerSortingClasses) ? headerSortingClasses(column, sortOrder, isLastSorting, index) : headerSortingClasses);

      cellStyle = _extends({}, cellStyle, _utils2.default.isFunction(headerSortingStyle) ? headerSortingStyle(column, sortOrder, isLastSorting, index) : headerSortingStyle);
    } else {
      sortSymbol = _react2.default.createElement(_symbol2.default, null);
    }
  }

  if (cellClasses) cellAttrs.className = (0, _classnames2.default)(cellAttrs.className, cellClasses);
  if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;

  if (filterRenderer) {
    var onCustomFilter = onExternalFilter(column, filter.props.type);
    filterElm = filterRenderer(onCustomFilter, column);
  } else if (filter) {
    filterElm = _react2.default.createElement(filter.Filter, _extends({}, filter.props, { onFilter: onFilter, column: column }));
  }

  var children = headerFormatter ? headerFormatter(column, index, { sortElement: sortSymbol, filterElement: filterElm }) : text;

  if (headerFormatter) {
    return _react2.default.createElement('th', cellAttrs, children);
  }

  return _react2.default.createElement('th', cellAttrs, children, sortSymbol, filterElm);
};

HeaderCell.propTypes = {
  column: _propTypes2.default.shape({
    dataField: _propTypes2.default.string.isRequired,
    text: _propTypes2.default.string.isRequired,
    hidden: _propTypes2.default.bool,
    headerFormatter: _propTypes2.default.func,
    formatter: _propTypes2.default.func,
    formatExtraData: _propTypes2.default.any,
    headerClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    classes: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    headerTitle: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    title: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    headerEvents: _propTypes2.default.object,
    events: _propTypes2.default.object,
    headerAlign: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    align: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    headerAttrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    attrs: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    sort: _propTypes2.default.bool,
    sortFunc: _propTypes2.default.func,
    onSort: _propTypes2.default.func,
    editor: _propTypes2.default.object,
    editable: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    editCellStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editCellClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    editorStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]),
    editorClasses: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    editorRenderer: _propTypes2.default.func,
    validator: _propTypes2.default.func,
    filter: _propTypes2.default.object,
    filterRenderer: _propTypes2.default.func,
    filterValue: _propTypes2.default.func
  }).isRequired,
  index: _propTypes2.default.number.isRequired,
  onSort: _propTypes2.default.func,
  sorting: _propTypes2.default.bool,
  sortOrder: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]),
  isLastSorting: _propTypes2.default.bool,
  onFilter: _propTypes2.default.func,
  onExternalFilter: _propTypes2.default.func
};

exports.default = HeaderCell;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortSymbol = function SortSymbol() {
  return _react2.default.createElement(
    _bootstrap.BootstrapContext.Consumer,
    null,
    function (_ref) {
      var bootstrap4 = _ref.bootstrap4;
      return bootstrap4 ? _react2.default.createElement('span', { className: 'order-4' }) : _react2.default.createElement(
        'span',
        { className: 'order' },
        _react2.default.createElement(
          'span',
          { className: 'dropdown' },
          _react2.default.createElement('span', { className: 'caret' })
        ),
        _react2.default.createElement(
          'span',
          { className: 'dropup' },
          _react2.default.createElement('span', { className: 'caret' })
        )
      );
    }
  );
};

exports.default = SortSymbol;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortCaret = function SortCaret(_ref) {
  var order = _ref.order;

  var orderClass = (0, _classnames2.default)('react-bootstrap-table-sort-order', {
    dropup: order === _const2.default.SORT_ASC
  });

  return _react2.default.createElement(
    _bootstrap.BootstrapContext.Consumer,
    null,
    function (_ref2) {
      var bootstrap4 = _ref2.bootstrap4;
      return bootstrap4 ? _react2.default.createElement('span', { className: 'caret-4-' + order }) : _react2.default.createElement(
        'span',
        { className: orderClass },
        _react2.default.createElement('span', { className: 'caret' })
      );
    }
  );
};

SortCaret.propTypes = {
  order: _propTypes2.default.oneOf([_const2.default.SORT_ASC, _const2.default.SORT_DESC]).isRequired
};

exports.default = SortCaret;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (true) {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckBox = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */


var CheckBox = exports.CheckBox = function CheckBox(_ref) {
  var className = _ref.className,
      checked = _ref.checked,
      indeterminate = _ref.indeterminate;
  return _react2.default.createElement('input', {
    type: 'checkbox',
    checked: checked,
    className: className,
    ref: function ref(input) {
      if (input) input.indeterminate = indeterminate; // eslint-disable-line no-param-reassign
    }
  });
};

CheckBox.propTypes = {
  checked: _propTypes2.default.bool.isRequired,
  indeterminate: _propTypes2.default.bool.isRequired,
  className: _propTypes2.default.string
};

var SelectionHeaderCell = function (_Component) {
  _inherits(SelectionHeaderCell, _Component);

  function SelectionHeaderCell() {
    _classCallCheck(this, SelectionHeaderCell);

    var _this = _possibleConstructorReturn(this, (SelectionHeaderCell.__proto__ || Object.getPrototypeOf(SelectionHeaderCell)).call(this));

    _this.handleCheckBoxClick = _this.handleCheckBoxClick.bind(_this);
    return _this;
  }

  /**
   * avoid updating if button is
   * 1. radio
   * 2. status was not changed.
   */


  _createClass(SelectionHeaderCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;
      var _props = this.props,
          mode = _props.mode,
          checkedStatus = _props.checkedStatus;


      if (mode === ROW_SELECT_SINGLE) return false;

      return nextProps.checkedStatus !== checkedStatus;
    }
  }, {
    key: 'handleCheckBoxClick',
    value: function handleCheckBoxClick(e) {
      var _props2 = this.props,
          onAllRowsSelect = _props2.onAllRowsSelect,
          checkedStatus = _props2.checkedStatus;

      var isUnSelect = checkedStatus === _const2.default.CHECKBOX_STATUS_CHECKED || checkedStatus === _const2.default.CHECKBOX_STATUS_INDETERMINATE;

      onAllRowsSelect(e, isUnSelect);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
          CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
          ROW_SELECT_MULTIPLE = _const2.default.ROW_SELECT_MULTIPLE;
      var _props3 = this.props,
          mode = _props3.mode,
          checkedStatus = _props3.checkedStatus,
          selectionHeaderRenderer = _props3.selectionHeaderRenderer;


      var checked = checkedStatus === CHECKBOX_STATUS_CHECKED;

      var indeterminate = checkedStatus === CHECKBOX_STATUS_INDETERMINATE;

      var attrs = {};
      var content = void 0;
      if (selectionHeaderRenderer || mode === ROW_SELECT_MULTIPLE) {
        attrs.onClick = this.handleCheckBoxClick;
      }

      return _react2.default.createElement(
        _bootstrap.BootstrapContext.Consumer,
        null,
        function (_ref2) {
          var bootstrap4 = _ref2.bootstrap4;

          if (selectionHeaderRenderer) {
            content = selectionHeaderRenderer({
              mode: mode,
              checked: checked,
              indeterminate: indeterminate
            });
          } else if (mode === ROW_SELECT_MULTIPLE) {
            content = _react2.default.createElement(CheckBox, _extends({}, _this2.props, {
              checked: checked,
              className: bootstrap4 ? 'selection-input-4' : '',
              indeterminate: indeterminate
            }));
          }
          return _react2.default.createElement(
            'th',
            _extends({ 'data-row-selection': true }, attrs),
            content
          );
        }
      );
    }
  }]);

  return SelectionHeaderCell;
}(_react.Component);

SelectionHeaderCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  checkedStatus: _propTypes2.default.string,
  onAllRowsSelect: _propTypes2.default.func,
  selectionHeaderRenderer: _propTypes2.default.func
};
exports.default = SelectionHeaderCell;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */
/* eslint no-nested-ternary: 0 */


var SelectionHeaderCell = function (_Component) {
  _inherits(SelectionHeaderCell, _Component);

  function SelectionHeaderCell() {
    _classCallCheck(this, SelectionHeaderCell);

    var _this = _possibleConstructorReturn(this, (SelectionHeaderCell.__proto__ || Object.getPrototypeOf(SelectionHeaderCell)).call(this));

    _this.handleCheckBoxClick = _this.handleCheckBoxClick.bind(_this);
    return _this;
  }

  _createClass(SelectionHeaderCell, [{
    key: 'handleCheckBoxClick',
    value: function handleCheckBoxClick(e) {
      var _props = this.props,
          anyExpands = _props.anyExpands,
          onAllRowExpand = _props.onAllRowExpand;


      onAllRowExpand(e, !anyExpands);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          anyExpands = _props2.anyExpands,
          renderer = _props2.renderer;

      var attrs = {
        onClick: this.handleCheckBoxClick
      };

      return _react2.default.createElement(
        'th',
        _extends({ 'data-row-selection': true }, attrs),
        renderer ? renderer({ isAnyExpands: anyExpands }) : anyExpands ? '(-)' : '(+)'
      );
    }
  }]);

  return SelectionHeaderCell;
}(_react.Component);

SelectionHeaderCell.propTypes = {
  anyExpands: _propTypes2.default.bool.isRequired,
  onAllRowExpand: _propTypes2.default.func.isRequired,
  renderer: _propTypes2.default.func
};
exports.default = SelectionHeaderCell;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint react/require-default-props: 0 */
var Caption = function Caption(props) {
  if (!props.children) return null;
  return _react2.default.createElement(
    'caption',
    null,
    props.children
  );
};

Caption.propTypes = {
  children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.string])
};

exports.default = Caption;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint react/prop-types: 0 */
/* eslint react/require-default-props: 0 */

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(5);

var _classnames2 = _interopRequireDefault(_classnames);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _row = __webpack_require__(23);

var _row2 = _interopRequireDefault(_row);

var _expandRow = __webpack_require__(28);

var _expandRow2 = _interopRequireDefault(_expandRow);

var _rowSection = __webpack_require__(29);

var _rowSection2 = _interopRequireDefault(_rowSection);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Body = function Body(props) {
  var columns = props.columns,
      data = props.data,
      keyField = props.keyField,
      isEmpty = props.isEmpty,
      noDataIndication = props.noDataIndication,
      visibleColumnSize = props.visibleColumnSize,
      cellEdit = props.cellEdit,
      selectRow = props.selectRow,
      selectedRowKeys = props.selectedRowKeys,
      rowStyle = props.rowStyle,
      rowClasses = props.rowClasses,
      rowEvents = props.rowEvents,
      expandRow = props.expandRow;
  var bgColor = selectRow.bgColor,
      nonSelectable = selectRow.nonSelectable;


  var content = void 0;

  if (isEmpty) {
    var indication = _utils2.default.isFunction(noDataIndication) ? noDataIndication() : noDataIndication;
    if (!indication) {
      return null;
    }
    content = _react2.default.createElement(_rowSection2.default, { content: indication, colSpan: visibleColumnSize });
  } else {
    var nonEditableRows = cellEdit.nonEditableRows || [];
    content = data.map(function (row, index) {
      var key = _utils2.default.get(row, keyField);
      var editable = !(nonEditableRows.length > 0 && nonEditableRows.indexOf(key) > -1);

      var selected = selectRow.mode !== _const2.default.ROW_SELECT_DISABLED ? selectedRowKeys.includes(key) : null;

      var attrs = rowEvents || {};
      var style = _utils2.default.isFunction(rowStyle) ? rowStyle(row, index) : rowStyle;
      var classes = _utils2.default.isFunction(rowClasses) ? rowClasses(row, index) : rowClasses;
      if (selected) {
        var selectedStyle = _utils2.default.isFunction(selectRow.style) ? selectRow.style(row, index) : selectRow.style;

        var selectedClasses = _utils2.default.isFunction(selectRow.classes) ? selectRow.classes(row, index) : selectRow.classes;

        style = _extends({}, style, selectedStyle);
        classes = (0, _classnames2.default)(classes, selectedClasses);

        if (bgColor) {
          style = style || {};
          style.backgroundColor = _utils2.default.isFunction(bgColor) ? bgColor(row, index) : bgColor;
        }
      }

      var selectable = !nonSelectable || !nonSelectable.includes(key);
      var expandable = expandRow && !expandRow.nonExpandable.includes(key);
      var expanded = expandRow && expandRow.expanded.includes(key);

      var result = [_react2.default.createElement(_row2.default, {
        key: key,
        row: row,
        keyField: keyField,
        rowIndex: index,
        columns: columns,
        cellEdit: cellEdit,
        editable: editable,
        selectable: selectable,
        expandable: expandable,
        selected: selected,
        expanded: expanded,
        selectRow: selectRow,
        expandRow: expandRow,
        style: style,
        className: classes,
        attrs: attrs
      })];

      if (expanded) {
        result.push(_react2.default.createElement(
          _expandRow2.default,
          {
            key: key + '-expanding',
            colSpan: visibleColumnSize
          },
          expandRow.renderer(row)
        ));
      }

      return result;
    });
  }

  return _react2.default.createElement(
    'tbody',
    null,
    content
  );
};

Body.propTypes = {
  keyField: _propTypes2.default.string.isRequired,
  data: _propTypes2.default.array.isRequired,
  columns: _propTypes2.default.array.isRequired,
  selectRow: _propTypes2.default.object,
  selectedRowKeys: _propTypes2.default.array
};

exports.default = Body;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _cell = __webpack_require__(24);

var _cell2 = _interopRequireDefault(_cell);

var _selectionCell = __webpack_require__(25);

var _selectionCell2 = _interopRequireDefault(_selectionCell);

var _expandCell = __webpack_require__(26);

var _expandCell2 = _interopRequireDefault(_expandCell);

var _rowEventDelegater = __webpack_require__(27);

var _rowEventDelegater2 = _interopRequireDefault(_rowEventDelegater);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */
/* eslint react/no-array-index-key: 0 */


var Row = function (_eventDelegater) {
  _inherits(Row, _eventDelegater);

  function Row() {
    _classCallCheck(this, Row);

    return _possibleConstructorReturn(this, (Row.__proto__ || Object.getPrototypeOf(Row)).apply(this, arguments));
  }

  _createClass(Row, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          row = _props.row,
          columns = _props.columns,
          keyField = _props.keyField,
          rowIndex = _props.rowIndex,
          className = _props.className,
          style = _props.style,
          attrs = _props.attrs,
          cellEdit = _props.cellEdit,
          selected = _props.selected,
          selectRow = _props.selectRow,
          expanded = _props.expanded,
          expandRow = _props.expandRow,
          selectable = _props.selectable,
          editableRow = _props.editable;

      var mode = cellEdit.mode,
          onStart = cellEdit.onStart,
          EditingCell = cellEdit.EditingCell,
          editingRowIdx = cellEdit.ridx,
          editingColIdx = cellEdit.cidx,
          CLICK_TO_CELL_EDIT = cellEdit.CLICK_TO_CELL_EDIT,
          DBCLICK_TO_CELL_EDIT = cellEdit.DBCLICK_TO_CELL_EDIT,
          rest = _objectWithoutProperties(cellEdit, ['mode', 'onStart', 'EditingCell', 'ridx', 'cidx', 'CLICK_TO_CELL_EDIT', 'DBCLICK_TO_CELL_EDIT']);

      var key = _utils2.default.get(row, keyField);
      var hideSelectColumn = selectRow.hideSelectColumn;

      var _ref = expandRow || {},
          showExpandColumn = _ref.showExpandColumn;

      var trAttrs = this.delegate(attrs);

      return _react2.default.createElement(
        'tr',
        _extends({ style: style, className: className }, trAttrs),
        showExpandColumn ? _react2.default.createElement(_expandCell2.default, _extends({}, expandRow, {
          rowKey: key,
          rowIndex: rowIndex,
          expanded: expanded
        })) : null,
        selectRow.mode !== _const2.default.ROW_SELECT_DISABLED && !hideSelectColumn ? _react2.default.createElement(_selectionCell2.default, _extends({}, selectRow, {
          rowKey: key,
          rowIndex: rowIndex,
          selected: selected,
          disabled: !selectable
        })) : null,
        columns.map(function (column, index) {
          if (!column.hidden) {
            var dataField = column.dataField;

            var content = _utils2.default.get(row, dataField);
            var editable = _utils2.default.isDefined(column.editable) ? column.editable : true;
            if (dataField === keyField || !editableRow) editable = false;
            if (_utils2.default.isFunction(column.editable)) {
              editable = column.editable(content, row, rowIndex, index);
            }
            if (rowIndex === editingRowIdx && index === editingColIdx) {
              var editCellstyle = column.editCellStyle || {};
              var editCellclasses = column.editCellClasses;
              if (_utils2.default.isFunction(column.editCellStyle)) {
                editCellstyle = column.editCellStyle(content, row, rowIndex, index);
              }
              if (_utils2.default.isFunction(column.editCellClasses)) {
                editCellclasses = column.editCellClasses(content, row, rowIndex, index);
              }
              return _react2.default.createElement(EditingCell, _extends({
                key: content + '-' + index,
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: index,
                className: editCellclasses,
                style: editCellstyle
              }, rest));
            }
            // render cell
            var cellTitle = void 0;
            var cellStyle = {};
            var cellAttrs = _extends({}, _utils2.default.isFunction(column.attrs) ? column.attrs(content, row, rowIndex, index) : column.attrs, column.events);

            var cellClasses = _utils2.default.isFunction(column.classes) ? column.classes(content, row, rowIndex, index) : column.classes;

            if (column.style) {
              cellStyle = _utils2.default.isFunction(column.style) ? column.style(content, row, rowIndex, index) : column.style;
              cellStyle = Object.assign({}, cellStyle) || {};
            }

            if (column.title) {
              cellTitle = _utils2.default.isFunction(column.title) ? column.title(content, row, rowIndex, index) : content;
              cellAttrs.title = cellTitle;
            }

            if (column.align) {
              cellStyle.textAlign = _utils2.default.isFunction(column.align) ? column.align(content, row, rowIndex, index) : column.align;
            }

            if (cellClasses) cellAttrs.className = cellClasses;
            if (!_utils2.default.isEmptyObject(cellStyle)) cellAttrs.style = cellStyle;

            return _react2.default.createElement(_cell2.default, _extends({
              key: content + '-' + index,
              row: row,
              rowIndex: rowIndex,
              columnIndex: index,
              column: column,
              onStart: onStart,
              editable: editable,
              clickToEdit: mode === CLICK_TO_CELL_EDIT,
              dbclickToEdit: mode === DBCLICK_TO_CELL_EDIT
            }, cellAttrs));
          }
          return false;
        })
      );
    }
  }]);

  return Row;
}((0, _rowEventDelegater2.default)(_react.Component));

Row.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  columns: _propTypes2.default.array.isRequired,
  style: _propTypes2.default.object,
  className: _propTypes2.default.string,
  attrs: _propTypes2.default.object
};

Row.defaultProps = {
  editable: true,
  style: {},
  className: null,
  attrs: {}
};

exports.default = Row;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


var Cell = function (_Component) {
  _inherits(Cell, _Component);

  function Cell(props) {
    _classCallCheck(this, Cell);

    var _this = _possibleConstructorReturn(this, (Cell.__proto__ || Object.getPrototypeOf(Cell)).call(this, props));

    _this.handleEditingCell = _this.handleEditingCell.bind(_this);
    return _this;
  }

  _createClass(Cell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var shouldUpdate = _utils2.default.get(this.props.row, this.props.column.dataField) !== _utils2.default.get(nextProps.row, nextProps.column.dataField) || this.props.column.hidden !== nextProps.column.hidden || this.props.rowIndex !== nextProps.rowIndex || this.props.columnIndex !== nextProps.columnIndex || this.props.className !== nextProps.className || this.props.title !== nextProps.title || this.props.editable !== nextProps.editable || this.props.clickToEdit !== nextProps.clickToEdit || this.props.dbclickToEdit !== nextProps.dbclickToEdit || !_utils2.default.isEqual(this.props.style, nextProps.style) || !_utils2.default.isEqual(this.props.column.formatExtraData, nextProps.column.formatExtraData) || !_utils2.default.isEqual(this.props.column.events, nextProps.column.events) || !_utils2.default.isEqual(this.props.column.attrs, nextProps.column.attrs);
      return shouldUpdate;
    }
  }, {
    key: 'handleEditingCell',
    value: function handleEditingCell(e) {
      var _props = this.props,
          column = _props.column,
          onStart = _props.onStart,
          rowIndex = _props.rowIndex,
          columnIndex = _props.columnIndex,
          clickToEdit = _props.clickToEdit,
          dbclickToEdit = _props.dbclickToEdit;
      var events = column.events;

      if (events) {
        if (clickToEdit) {
          var customClick = events.onClick;
          if (_utils2.default.isFunction(customClick)) customClick(e);
        } else if (dbclickToEdit) {
          var customDbClick = events.onDoubleClick;
          if (_utils2.default.isFunction(customDbClick)) customDbClick(e);
        }
      }
      if (onStart) {
        onStart(rowIndex, columnIndex);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          row = _props2.row,
          rowIndex = _props2.rowIndex,
          column = _props2.column,
          columnIndex = _props2.columnIndex,
          onStart = _props2.onStart,
          editable = _props2.editable,
          clickToEdit = _props2.clickToEdit,
          dbclickToEdit = _props2.dbclickToEdit,
          rest = _objectWithoutProperties(_props2, ['row', 'rowIndex', 'column', 'columnIndex', 'onStart', 'editable', 'clickToEdit', 'dbclickToEdit']);

      var dataField = column.dataField,
          formatter = column.formatter,
          formatExtraData = column.formatExtraData;

      var attrs = _extends({}, rest);
      var content = _utils2.default.get(row, dataField);

      if (formatter) {
        content = column.formatter(content, row, rowIndex, formatExtraData);
      }

      if (clickToEdit && editable) {
        attrs.onClick = this.handleEditingCell;
      } else if (dbclickToEdit && editable) {
        attrs.onDoubleClick = this.handleEditingCell;
      }

      return _react2.default.createElement(
        'td',
        attrs,
        typeof content === 'boolean' ? '' + content : content
      );
    }
  }]);

  return Cell;
}(_react.Component);

Cell.propTypes = {
  row: _propTypes2.default.object.isRequired,
  rowIndex: _propTypes2.default.number.isRequired,
  column: _propTypes2.default.object.isRequired,
  columnIndex: _propTypes2.default.number.isRequired
};

exports.default = Cell;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _bootstrap = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 react/require-default-props: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 jsx-a11y/no-noninteractive-element-interactions: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */


var SelectionCell = function (_Component) {
  _inherits(SelectionCell, _Component);

  function SelectionCell() {
    _classCallCheck(this, SelectionCell);

    var _this = _possibleConstructorReturn(this, (SelectionCell.__proto__ || Object.getPrototypeOf(SelectionCell)).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(SelectionCell, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var selected = this.props.selected;


      return nextProps.selected !== selected;
    }
  }, {
    key: 'handleClick',
    value: function handleClick(e) {
      var _props = this.props,
          inputType = _props.mode,
          rowKey = _props.rowKey,
          selected = _props.selected,
          onRowSelect = _props.onRowSelect,
          disabled = _props.disabled,
          rowIndex = _props.rowIndex,
          clickToSelect = _props.clickToSelect;


      if (disabled) return;
      if (clickToSelect) return;

      var checked = inputType === _const2.default.ROW_SELECT_SINGLE ? true : !selected;

      onRowSelect(rowKey, checked, rowIndex, e);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props2 = this.props,
          inputType = _props2.mode,
          selected = _props2.selected,
          disabled = _props2.disabled,
          selectionRenderer = _props2.selectionRenderer;


      return _react2.default.createElement(
        _bootstrap.BootstrapContext.Consumer,
        null,
        function (_ref) {
          var bootstrap4 = _ref.bootstrap4;
          return _react2.default.createElement(
            'td',
            { onClick: _this2.handleClick },
            selectionRenderer ? selectionRenderer({
              mode: inputType,
              checked: selected,
              disabled: disabled
            }) : _react2.default.createElement('input', {
              type: inputType,
              checked: selected,
              disabled: disabled,
              className: bootstrap4 ? 'selection-input-4' : ''
            })
          );
        }
      );
    }
  }]);

  return SelectionCell;
}(_react.Component);

SelectionCell.propTypes = {
  mode: _propTypes2.default.string.isRequired,
  rowKey: _propTypes2.default.any,
  selected: _propTypes2.default.bool,
  onRowSelect: _propTypes2.default.func,
  disabled: _propTypes2.default.bool,
  rowIndex: _propTypes2.default.number,
  clickToSelect: _propTypes2.default.bool,
  selectionRenderer: _propTypes2.default.func
};
exports.default = SelectionCell;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 react/require-default-props: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 jsx-a11y/no-noninteractive-element-interactions: 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */
/* eslint no-nested-ternary: 0 */


var ExpandCell = function (_Component) {
  _inherits(ExpandCell, _Component);

  function ExpandCell() {
    _classCallCheck(this, ExpandCell);

    var _this = _possibleConstructorReturn(this, (ExpandCell.__proto__ || Object.getPrototypeOf(ExpandCell)).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(ExpandCell, [{
    key: 'handleClick',
    value: function handleClick(e) {
      var _props = this.props,
          rowKey = _props.rowKey,
          expanded = _props.expanded,
          onRowExpand = _props.onRowExpand,
          rowIndex = _props.rowIndex;


      onRowExpand(rowKey, expanded, rowIndex, e);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          expanded = _props2.expanded,
          expandColumnRenderer = _props2.expandColumnRenderer;


      return _react2.default.createElement(
        'td',
        { onClick: this.handleClick },
        expandColumnRenderer ? expandColumnRenderer({
          expanded: expanded
        }) : expanded ? '(-)' : '(+)'
      );
    }
  }]);

  return ExpandCell;
}(_react.Component);

ExpandCell.propTypes = {
  rowKey: _propTypes2.default.any,
  expanded: _propTypes2.default.bool.isRequired,
  onRowExpand: _propTypes2.default.func.isRequired,
  expandColumnRenderer: _propTypes2.default.func,
  rowIndex: _propTypes2.default.number
};
exports.default = ExpandCell;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var events = ['onClick', 'onDoubleClick', 'onMouseEnter', 'onMouseLeave'];

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RowEventDelegater, _ExtendBase);

    function RowEventDelegater(props) {
      _classCallCheck(this, RowEventDelegater);

      var _this = _possibleConstructorReturn(this, (RowEventDelegater.__proto__ || Object.getPrototypeOf(RowEventDelegater)).call(this, props));

      _this.clickNum = 0;
      _this.createDefaultEventHandler = _this.createDefaultEventHandler.bind(_this);
      _this.createClickEventHandler = _this.createClickEventHandler.bind(_this);
      return _this;
    }

    _createClass(RowEventDelegater, [{
      key: 'createDefaultEventHandler',
      value: function createDefaultEventHandler(cb) {
        var _this2 = this;

        return function (e) {
          var _props = _this2.props,
              row = _props.row,
              rowIndex = _props.rowIndex;

          cb(e, row, rowIndex);
        };
      }
    }, {
      key: 'createClickEventHandler',
      value: function createClickEventHandler(cb) {
        var _this3 = this;

        return function (e) {
          var _props2 = _this3.props,
              row = _props2.row,
              selected = _props2.selected,
              keyField = _props2.keyField,
              selectable = _props2.selectable,
              expandable = _props2.expandable,
              rowIndex = _props2.rowIndex,
              expanded = _props2.expanded,
              expandRow = _props2.expandRow,
              selectRow = _props2.selectRow,
              _props2$cellEdit = _props2.cellEdit,
              mode = _props2$cellEdit.mode,
              DBCLICK_TO_CELL_EDIT = _props2$cellEdit.DBCLICK_TO_CELL_EDIT,
              DELAY_FOR_DBCLICK = _props2$cellEdit.DELAY_FOR_DBCLICK;


          var clickFn = function clickFn() {
            if (cb) {
              cb(e, row, rowIndex);
            }
            var key = _utils2.default.get(row, keyField);
            if (expandRow && expandable) {
              expandRow.onRowExpand(key, !expanded, rowIndex, e);
            }
            if (selectRow.mode !== _const2.default.ROW_SELECT_DISABLED && selectable) {
              selectRow.onRowSelect(key, !selected, rowIndex, e);
            }
          };

          if (mode === DBCLICK_TO_CELL_EDIT && selectRow.clickToEdit) {
            _this3.clickNum += 1;
            _utils2.default.debounce(function () {
              if (_this3.clickNum === 1) {
                clickFn();
              }
              _this3.clickNum = 0;
            }, DELAY_FOR_DBCLICK)();
          } else {
            clickFn();
          }
        };
      }
    }, {
      key: 'delegate',
      value: function delegate() {
        var _this4 = this;

        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var newAttrs = {};
        var _props3 = this.props,
            expandRow = _props3.expandRow,
            selectRow = _props3.selectRow;

        if (expandRow || selectRow && selectRow.clickToSelect) {
          newAttrs.onClick = this.createClickEventHandler(attrs.onClick);
        }
        Object.keys(attrs).forEach(function (attr) {
          if (!newAttrs[attr]) {
            if (events.includes(attr)) {
              newAttrs[attr] = _this4.createDefaultEventHandler(attrs[attr]);
            } else {
              newAttrs[attr] = attrs[attr];
            }
          }
        });
        return newAttrs;
      }
    }]);

    return RowEventDelegater;
  }(ExtendBase);
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ExpandRow = function ExpandRow(_ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['children']);

  return _react2.default.createElement(
    'tr',
    { className: 'expanding-row' },
    _react2.default.createElement(
      'td',
      rest,
      children
    )
  );
};

ExpandRow.propTypes = {
  children: _propTypes2.default.node
};

ExpandRow.defaultProps = {
  children: null
};

exports.default = ExpandRow;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RowSection = function RowSection(_ref) {
  var content = _ref.content,
      colSpan = _ref.colSpan;
  return _react2.default.createElement(
    'tr',
    null,
    _react2.default.createElement(
      'td',
      {
        'data-toggle': 'collapse',
        colSpan: colSpan,
        className: 'react-bs-table-no-data'
      },
      content
    )
  );
};

RowSection.propTypes = {
  content: _propTypes2.default.any,
  colSpan: _propTypes2.default.number
};

RowSection.defaultProps = {
  content: null,
  colSpan: 1
};

exports.default = RowSection;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _columnResolver = __webpack_require__(31);

var _columnResolver2 = _interopRequireDefault(_columnResolver);

var _expandRowResolver = __webpack_require__(32);

var _expandRowResolver2 = _interopRequireDefault(_expandRowResolver);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExpandRowResolver) {
    _inherits(TableResolver, _ExpandRowResolver);

    function TableResolver() {
      _classCallCheck(this, TableResolver);

      return _possibleConstructorReturn(this, (TableResolver.__proto__ || Object.getPrototypeOf(TableResolver)).apply(this, arguments));
    }

    _createClass(TableResolver, [{
      key: 'validateProps',
      value: function validateProps() {
        var keyField = this.props.keyField;

        if (!keyField) {
          throw new Error('Please specify a field as key via keyField');
        }
        if (this.visibleColumnSize(false) <= 0) {
          throw new Error('No visible columns detected');
        }
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        return this.props.data.length === 0;
      }

      /**
       * props resolver for cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       */

    }, {
      key: 'resolveSelectRowProps',
      value: function resolveSelectRowProps(options) {
        var selectRow = this.props.selectRow;
        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED;


        if (_utils2.default.isDefined(selectRow)) {
          return _extends({}, selectRow, options);
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }

      /**
       * props resolver for header cell selection
       * @param {Object} options - addtional options like callback which are about to merge into props
       *
       * @returns {Object} result - props for cell selections
       * @returns {String} result.mode - input type of row selection or disabled.
       * @returns {String} result.checkedStatus - checkbox status depending on selected rows counts
       */

    }, {
      key: 'resolveSelectRowPropsForHeader',
      value: function resolveSelectRowPropsForHeader() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var selectRow = this.props.selectRow;

        var allRowsSelected = options.allRowsSelected,
            allRowsNotSelected = options.allRowsNotSelected,
            rest = _objectWithoutProperties(options, ['allRowsSelected', 'allRowsNotSelected']);

        var ROW_SELECT_DISABLED = _const2.default.ROW_SELECT_DISABLED,
            CHECKBOX_STATUS_CHECKED = _const2.default.CHECKBOX_STATUS_CHECKED,
            CHECKBOX_STATUS_INDETERMINATE = _const2.default.CHECKBOX_STATUS_INDETERMINATE,
            CHECKBOX_STATUS_UNCHECKED = _const2.default.CHECKBOX_STATUS_UNCHECKED;


        if (_utils2.default.isDefined(selectRow)) {
          var checkedStatus = void 0;

          // checkbox status depending on selected rows counts
          if (allRowsSelected) checkedStatus = CHECKBOX_STATUS_CHECKED;else if (allRowsNotSelected) checkedStatus = CHECKBOX_STATUS_UNCHECKED;else checkedStatus = CHECKBOX_STATUS_INDETERMINATE;

          return _extends({}, selectRow, rest, {
            checkedStatus: checkedStatus
          });
        }

        return {
          mode: ROW_SELECT_DISABLED
        };
      }
    }]);

    return TableResolver;
  }((0, _expandRowResolver2.default)((0, _columnResolver2.default)(ExtendBase)));
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(ColumnResolver, _ExtendBase);

    function ColumnResolver() {
      _classCallCheck(this, ColumnResolver);

      return _possibleConstructorReturn(this, (ColumnResolver.__proto__ || Object.getPrototypeOf(ColumnResolver)).apply(this, arguments));
    }

    _createClass(ColumnResolver, [{
      key: "visibleColumnSize",
      value: function visibleColumnSize() {
        var includeSelectColumn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var columnLen = this.props.columns.filter(function (c) {
          return !c.hidden;
        }).length;
        if (!includeSelectColumn) return columnLen;
        if (this.props.selectRow && !this.props.selectRow.hideSelectColumn) {
          columnLen += 1;
        }
        if (this.props.expandRow && this.props.expandRow.showExpandColumn) {
          columnLen += 1;
        }
        return columnLen;
      }
    }]);

    return ColumnResolver;
  }(ExtendBase);
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(ExpandRowResolver, _ExtendBase);

    function ExpandRowResolver() {
      _classCallCheck(this, ExpandRowResolver);

      return _possibleConstructorReturn(this, (ExpandRowResolver.__proto__ || Object.getPrototypeOf(ExpandRowResolver)).apply(this, arguments));
    }

    _createClass(ExpandRowResolver, [{
      key: "resolveExpandRowProps",
      value: function resolveExpandRowProps() {
        var _props = this.props,
            expandRow = _props.expandRow,
            expanded = _props.expanded,
            onRowExpand = _props.onRowExpand,
            onAllRowExpand = _props.onAllRowExpand,
            isAnyExpands = _props.isAnyExpands;

        if (expandRow) {
          return _extends({}, expandRow, {
            expanded: expanded,
            onRowExpand: onRowExpand,
            onAllRowExpand: onAllRowExpand,
            isAnyExpands: isAnyExpands,
            nonExpandable: expandRow.nonExpandable || []
          });
        }
        return null;
      }
    }]);

    return ExpandRowResolver;
  }(ExtendBase);
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _dataContext = __webpack_require__(34);

var _dataContext2 = _interopRequireDefault(_dataContext);

var _sortContext = __webpack_require__(35);

var _sortContext2 = _interopRequireDefault(_sortContext);

var _selectionContext = __webpack_require__(36);

var _selectionContext2 = _interopRequireDefault(_selectionContext);

var _rowExpandContext = __webpack_require__(37);

var _rowExpandContext2 = _interopRequireDefault(_rowExpandContext);

var _remoteResolver2 = __webpack_require__(38);

var _remoteResolver3 = _interopRequireDefault(_remoteResolver2);

var _bootstrap = __webpack_require__(4);

var _operators = __webpack_require__(39);

var _operators2 = _interopRequireDefault(_operators);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-return-assign: 0 */
/* eslint class-methods-use-this: 0 */


var withContext = function withContext(Base) {
  return function (_remoteResolver) {
    _inherits(BootstrapTableContainer, _remoteResolver);

    function BootstrapTableContainer(props) {
      _classCallCheck(this, BootstrapTableContainer);

      var _this = _possibleConstructorReturn(this, (BootstrapTableContainer.__proto__ || Object.getPrototypeOf(BootstrapTableContainer)).call(this, props));

      _this.DataContext = (0, _dataContext2.default)();

      if (props.columns.filter(function (col) {
        return col.sort;
      }).length > 0) {
        _this.SortContext = (0, _sortContext2.default)(_operators2.default, _this.isRemoteSort, _this.handleRemoteSortChange);
      }

      if (props.selectRow) {
        _this.SelectionContext = (0, _selectionContext2.default)(_operators2.default);
      }

      if (props.expandRow) {
        _this.RowExpandContext = (0, _rowExpandContext2.default)(_operators2.default);
      }

      if (props.cellEdit && props.cellEdit.createContext) {
        _this.CellEditContext = props.cellEdit.createContext(_utils2.default, _operators2.default, _this.isRemoteCellEdit, _this.handleRemoteCellChange);
      }

      if (props.filter) {
        _this.FilterContext = props.filter.createContext(_utils2.default, _this.isRemoteFiltering, _this.handleRemoteFilterChange);
      }

      if (props.pagination) {
        _this.PaginationContext = props.pagination.createContext(_this.isRemotePagination, _this.handleRemotePageChange);
      }

      if (props.search && props.search.searchContext) {
        _this.SearchContext = props.search.searchContext(_utils2.default, _this.isRemoteSearch, _this.handleRemoteSearchChange);
      }

      if (props.setDependencyModules) {
        props.setDependencyModules(_utils2.default);
      }
      return _this;
    }

    _createClass(BootstrapTableContainer, [{
      key: 'renderBase',
      value: function renderBase() {
        var _this2 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps, selectionProps) {
          return _react2.default.createElement(Base, _extends({}, _this2.props, selectionProps, sortProps, cellEditProps, filterProps, searchProps, paginationProps, expandProps, {
            data: rootProps.getData(filterProps, searchProps, sortProps, paginationProps)
          }));
        };
      }
    }, {
      key: 'renderWithSelectionCtx',
      value: function renderWithSelectionCtx(base, baseProps) {
        var _this3 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps) {
          return _react2.default.createElement(
            _this3.SelectionContext.Provider,
            _extends({}, baseProps, {
              selectRow: _this3.props.selectRow,
              data: rootProps.getData(filterProps, searchProps, sortProps, paginationProps)
            }),
            _react2.default.createElement(
              _this3.SelectionContext.Consumer,
              null,
              function (selectionProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps, selectionProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithRowExpandCtx',
      value: function renderWithRowExpandCtx(base, baseProps) {
        var _this4 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps) {
          return _react2.default.createElement(
            _this4.RowExpandContext.Provider,
            _extends({}, baseProps, {
              expandRow: _this4.props.expandRow,
              data: rootProps.getData(filterProps, searchProps, sortProps, paginationProps)
            }),
            _react2.default.createElement(
              _this4.RowExpandContext.Consumer,
              null,
              function (expandProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps, expandProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithPaginationCtx',
      value: function renderWithPaginationCtx(base) {
        var _this5 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps, sortProps) {
          return _react2.default.createElement(
            _this5.PaginationContext.Provider,
            {
              ref: function ref(n) {
                return _this5.paginationContext = n;
              },
              pagination: _this5.props.pagination,
              data: rootProps.getData(filterProps, searchProps, sortProps),
              bootstrap4: _this5.props.bootstrap4
            },
            _react2.default.createElement(
              _this5.PaginationContext.Consumer,
              null,
              function (paginationProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps, paginationProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithSortCtx',
      value: function renderWithSortCtx(base, baseProps) {
        var _this6 = this;

        return function (rootProps, cellEditProps, filterProps, searchProps) {
          return _react2.default.createElement(
            _this6.SortContext.Provider,
            _extends({}, baseProps, {
              ref: function ref(n) {
                return _this6.sortContext = n;
              },
              defaultSorted: _this6.props.defaultSorted,
              defaultSortDirection: _this6.props.defaultSortDirection,
              data: rootProps.getData(filterProps, searchProps)
            }),
            _react2.default.createElement(
              _this6.SortContext.Consumer,
              null,
              function (sortProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps, sortProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithSearchCtx',
      value: function renderWithSearchCtx(base, baseProps) {
        var _this7 = this;

        return function (rootProps, cellEditProps, filterProps) {
          return _react2.default.createElement(
            _this7.SearchContext.Provider,
            _extends({}, baseProps, {
              ref: function ref(n) {
                return _this7.searchContext = n;
              },
              data: rootProps.getData(filterProps),
              searchText: _this7.props.search.searchText
            }),
            _react2.default.createElement(
              _this7.SearchContext.Consumer,
              null,
              function (searchProps) {
                return base(rootProps, cellEditProps, filterProps, searchProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithFilterCtx',
      value: function renderWithFilterCtx(base, baseProps) {
        var _this8 = this;

        return function (rootProps, cellEditProps) {
          return _react2.default.createElement(
            _this8.FilterContext.Provider,
            _extends({}, baseProps, {
              ref: function ref(n) {
                return _this8.filterContext = n;
              },
              data: rootProps.getData()
            }),
            _react2.default.createElement(
              _this8.FilterContext.Consumer,
              null,
              function (filterProps) {
                return base(rootProps, cellEditProps, filterProps);
              }
            )
          );
        };
      }
    }, {
      key: 'renderWithCellEditCtx',
      value: function renderWithCellEditCtx(base, baseProps) {
        var _this9 = this;

        return function (rootProps) {
          return _react2.default.createElement(
            _this9.CellEditContext.Provider,
            _extends({}, baseProps, {
              selectRow: _this9.props.selectRow,
              cellEdit: _this9.props.cellEdit,
              data: rootProps.getData()
            }),
            _react2.default.createElement(
              _this9.CellEditContext.Consumer,
              null,
              function (cellEditProps) {
                return base(rootProps, cellEditProps);
              }
            )
          );
        };
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            keyField = _props.keyField,
            columns = _props.columns,
            bootstrap4 = _props.bootstrap4;

        var baseProps = { keyField: keyField, columns: columns };

        var base = this.renderBase();

        if (this.SelectionContext) {
          base = this.renderWithSelectionCtx(base, baseProps);
        }

        if (this.RowExpandContext) {
          base = this.renderWithRowExpandCtx(base, baseProps);
        }

        if (this.PaginationContext) {
          base = this.renderWithPaginationCtx(base, baseProps);
        }

        if (this.SortContext) {
          base = this.renderWithSortCtx(base, baseProps);
        }

        if (this.SearchContext) {
          base = this.renderWithSearchCtx(base, baseProps);
        }

        if (this.FilterContext) {
          base = this.renderWithFilterCtx(base, baseProps);
        }

        if (this.CellEditContext) {
          base = this.renderWithCellEditCtx(base, baseProps);
        }

        return _react2.default.createElement(
          _bootstrap.BootstrapContext.Provider,
          { value: { bootstrap4: bootstrap4 } },
          _react2.default.createElement(
            this.DataContext.Provider,
            _extends({}, baseProps, {
              data: this.props.data
            }),
            _react2.default.createElement(
              this.DataContext.Consumer,
              null,
              base
            )
          )
        );
      }
    }]);

    return BootstrapTableContainer;
  }((0, _remoteResolver3.default)(_react.Component));
};

exports.default = withContext;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function () {
  var DataContext = _react2.default.createContext();

  var DataProvider = function (_Component) {
    _inherits(DataProvider, _Component);

    function DataProvider() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, DataProvider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DataProvider.__proto__ || Object.getPrototypeOf(DataProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = { data: _this.props.data }, _this.getData = function (filterProps, searchProps, sortProps, paginationProps) {
        if (paginationProps) return paginationProps.data;else if (sortProps) return sortProps.data;else if (searchProps) return searchProps.data;else if (filterProps) return filterProps.data;
        return _this.props.data;
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(DataProvider, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.setState(function () {
          return { data: nextProps.data };
        });
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(
          DataContext.Provider,
          {
            value: {
              data: this.state.data,
              getData: this.getData
            }
          },
          this.props.children
        );
      }
    }]);

    return DataProvider;
  }(_react.Component);

  DataProvider.propTypes = {
    data: _propTypes2.default.array.isRequired,
    children: _propTypes2.default.node.isRequired
  };

  return {
    Provider: DataProvider,
    Consumer: DataContext.Consumer
  };
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/require-default-props: 0 */


exports.default = function (dataOperator, isRemoteSort, handleSortChange) {
  var SortContext = _react2.default.createContext();

  var SortProvider = function (_React$Component) {
    _inherits(SortProvider, _React$Component);

    function SortProvider(props) {
      _classCallCheck(this, SortProvider);

      var _this = _possibleConstructorReturn(this, (SortProvider.__proto__ || Object.getPrototypeOf(SortProvider)).call(this, props));

      _initialiseProps.call(_this);

      var sortOrder = void 0;
      var sortColumn = void 0;
      var columns = props.columns,
          defaultSorted = props.defaultSorted,
          defaultSortDirection = props.defaultSortDirection;


      if (defaultSorted && defaultSorted.length > 0) {
        var sortField = defaultSorted[0].dataField;
        sortOrder = defaultSorted[0].order || defaultSortDirection;
        var sortColumns = columns.filter(function (col) {
          return col.dataField === sortField;
        });
        if (sortColumns.length > 0) {
          sortColumn = sortColumns[0];

          if (sortColumn.onSort) {
            sortColumn.onSort(sortField, sortOrder);
          }
        }
      }
      _this.state = { sortOrder: sortOrder, sortColumn: sortColumn };
      return _this;
    }

    _createClass(SortProvider, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _state = this.state,
            sortOrder = _state.sortOrder,
            sortColumn = _state.sortColumn;

        if (isRemoteSort() && sortOrder && sortColumn) {
          handleSortChange(sortColumn.dataField, sortOrder);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var data = this.props.data;
        var _state2 = this.state,
            sortOrder = _state2.sortOrder,
            sortColumn = _state2.sortColumn;

        if (!isRemoteSort() && sortColumn) {
          data = dataOperator.sort(data, sortOrder, sortColumn);
        }

        return _react2.default.createElement(
          SortContext.Provider,
          {
            value: {
              data: data,
              sortOrder: sortOrder,
              onSort: this.handleSort,
              sortField: sortColumn ? sortColumn.dataField : null
            }
          },
          this.props.children
        );
      }
    }]);

    return SortProvider;
  }(_react2.default.Component);

  SortProvider.propTypes = {
    data: _propTypes2.default.array.isRequired,
    columns: _propTypes2.default.array.isRequired,
    children: _propTypes2.default.node.isRequired,
    defaultSorted: _propTypes2.default.arrayOf(_propTypes2.default.shape({
      dataField: _propTypes2.default.string.isRequired,
      order: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC]).isRequired
    })),
    defaultSortDirection: _propTypes2.default.oneOf([_const2.default.SORT_DESC, _const2.default.SORT_ASC])
  };

  var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.handleSort = function (column) {
      var sortOrder = dataOperator.nextOrder(column, _this2.state, _this2.props.defaultSortDirection);

      if (column.onSort) {
        column.onSort(column.dataField, sortOrder);
      }

      if (isRemoteSort()) {
        handleSortChange(column.dataField, sortOrder);
      }
      _this2.setState(function () {
        return {
          sortOrder: sortOrder,
          sortColumn: column
        };
      });
    };
  };

  return {
    Provider: SortProvider,
    Consumer: SortContext.Consumer
  };
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (dataOperator) {
  var SelectionContext = _react2.default.createContext();

  var SelectionProvider = function (_React$Component) {
    _inherits(SelectionProvider, _React$Component);

    function SelectionProvider() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, SelectionProvider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = SelectionProvider.__proto__ || Object.getPrototypeOf(SelectionProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = { selected: _this.props.selectRow && _this.props.selectRow.selected || [] }, _this.handleRowSelect = function (rowKey, checked, rowIndex, e) {
        var _this$props = _this.props,
            data = _this$props.data,
            keyField = _this$props.keyField,
            _this$props$selectRow = _this$props.selectRow,
            mode = _this$props$selectRow.mode,
            onSelect = _this$props$selectRow.onSelect;
        var ROW_SELECT_SINGLE = _const2.default.ROW_SELECT_SINGLE;


        var currSelected = [].concat(_toConsumableArray(_this.state.selected));

        if (mode === ROW_SELECT_SINGLE) {
          // when select mode is radio
          currSelected = [rowKey];
        } else if (checked) {
          // when select mode is checkbox
          currSelected.push(rowKey);
        } else {
          currSelected = currSelected.filter(function (value) {
            return value !== rowKey;
          });
        }

        if (onSelect) {
          var row = dataOperator.getRowByRowId(data, keyField, rowKey);
          onSelect(row, checked, rowIndex, e);
        }

        _this.setState(function () {
          return { selected: currSelected };
        });
      }, _this.handleAllRowsSelect = function (e, isUnSelect) {
        var _this$props2 = _this.props,
            data = _this$props2.data,
            keyField = _this$props2.keyField,
            _this$props2$selectRo = _this$props2.selectRow,
            onSelectAll = _this$props2$selectRo.onSelectAll,
            nonSelectable = _this$props2$selectRo.nonSelectable;
        var selected = _this.state.selected;


        var currSelected = void 0;

        if (!isUnSelect) {
          currSelected = selected.concat(dataOperator.selectableKeys(data, keyField, nonSelectable));
        } else {
          currSelected = selected.filter(function (s) {
            return typeof data.find(function (d) {
              return d[keyField] === s;
            }) === 'undefined';
          });
        }

        if (onSelectAll) {
          onSelectAll(!isUnSelect, dataOperator.getSelectedRows(data, keyField, currSelected), e);
        }

        _this.setState(function () {
          return { selected: currSelected };
        });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(SelectionProvider, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _this2 = this;

        if (nextProps.selectRow) {
          this.setState(function () {
            return {
              selected: nextProps.selectRow.selected || _this2.state.selected
            };
          });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(
          SelectionContext.Provider,
          {
            value: {
              selected: this.state.selected,
              onRowSelect: this.handleRowSelect,
              onAllRowsSelect: this.handleAllRowsSelect
            }
          },
          this.props.children
        );
      }
    }]);

    return SelectionProvider;
  }(_react2.default.Component);

  SelectionProvider.propTypes = {
    children: _propTypes2.default.node.isRequired,
    data: _propTypes2.default.array.isRequired,
    keyField: _propTypes2.default.string.isRequired
  };

  return {
    Provider: SelectionProvider,
    Consumer: SelectionContext.Consumer
  };
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (dataOperator) {
  var RowExpandContext = _react2.default.createContext();

  var RowExpandProvider = function (_React$Component) {
    _inherits(RowExpandProvider, _React$Component);

    function RowExpandProvider() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, RowExpandProvider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = RowExpandProvider.__proto__ || Object.getPrototypeOf(RowExpandProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = { expanded: _this.props.expandRow.expanded || [] }, _this.handleRowExpand = function (rowKey, expanded, rowIndex, e) {
        var _this$props = _this.props,
            data = _this$props.data,
            keyField = _this$props.keyField,
            onExpand = _this$props.expandRow.onExpand;


        var currExpanded = [].concat(_toConsumableArray(_this.state.expanded));

        if (expanded) {
          currExpanded.push(rowKey);
        } else {
          currExpanded = currExpanded.filter(function (value) {
            return value !== rowKey;
          });
        }

        if (onExpand) {
          var row = dataOperator.getRowByRowId(data, keyField, rowKey);
          onExpand(row, expanded, rowIndex, e);
        }
        _this.setState(function () {
          return { expanded: currExpanded };
        });
      }, _this.handleAllRowExpand = function (e, expandAll) {
        var _this$props2 = _this.props,
            data = _this$props2.data,
            keyField = _this$props2.keyField,
            _this$props2$expandRo = _this$props2.expandRow,
            onExpandAll = _this$props2$expandRo.onExpandAll,
            nonExpandable = _this$props2$expandRo.nonExpandable;
        var expanded = _this.state.expanded;


        var currExpanded = void 0;

        if (expandAll) {
          currExpanded = expanded.concat(dataOperator.expandableKeys(data, keyField, nonExpandable));
        } else {
          currExpanded = expanded.filter(function (s) {
            return typeof data.find(function (d) {
              return d[keyField] === s;
            }) === 'undefined';
          });
        }

        if (onExpandAll) {
          onExpandAll(expandAll, dataOperator.getExpandedRows(data, keyField, currExpanded), e);
        }

        _this.setState(function () {
          return { expanded: currExpanded };
        });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(RowExpandProvider, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _this2 = this;

        if (nextProps.expandRow) {
          this.setState(function () {
            return {
              expanded: nextProps.expandRow.expanded || _this2.state.expanded
            };
          });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            data = _props.data,
            keyField = _props.keyField;

        return _react2.default.createElement(
          RowExpandContext.Provider,
          {
            value: {
              isAnyExpands: dataOperator.isAnyExpands(data, keyField, this.state.expanded),
              expanded: this.state.expanded,
              onRowExpand: this.handleRowExpand,
              onAllRowExpand: this.handleAllRowExpand
            }
          },
          this.props.children
        );
      }
    }]);

    return RowExpandProvider;
  }(_react2.default.Component);

  RowExpandProvider.propTypes = {
    children: _propTypes2.default.node.isRequired,
    data: _propTypes2.default.array.isRequired,
    keyField: _propTypes2.default.string.isRequired
  };

  return {
    Provider: RowExpandProvider,
    Consumer: RowExpandContext.Consumer
  };
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = function (ExtendBase) {
  return function (_ExtendBase) {
    _inherits(RemoteResolver, _ExtendBase);

    function RemoteResolver() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, RemoteResolver);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = RemoteResolver.__proto__ || Object.getPrototypeOf(RemoteResolver)).call.apply(_ref, [this].concat(args))), _this), _this.getNewestState = function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var sortOrder = void 0;
        var sortField = void 0;
        var page = void 0;
        var sizePerPage = void 0;
        var searchText = void 0;
        var filters = {};

        if (_this.sortContext) {
          sortOrder = _this.sortContext.state.sortOrder;
          sortField = _this.sortContext.state.sortColumn ? _this.sortContext.state.sortColumn.dataField : null;
        }

        if (_this.filterContext) {
          filters = _this.filterContext.currFilters;
        }

        if (_this.paginationContext) {
          page = _this.paginationContext.currPage;
          sizePerPage = _this.paginationContext.currSizePerPage;
        }

        if (_this.searchContext) {
          searchText = _this.props.search.searchText;
        }

        return _extends({
          sortOrder: sortOrder,
          sortField: sortField,
          filters: filters,
          page: page,
          sizePerPage: sizePerPage,
          searchText: searchText
        }, state, {
          data: _this.props.data
        });
      }, _this.isRemoteSearch = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.search || _this.isRemotePagination();
      }, _this.isRemotePagination = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.pagination;
      }, _this.isRemoteFiltering = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.filter || _this.isRemotePagination();
      }, _this.isRemoteSort = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.sort || _this.isRemotePagination();
      }, _this.isRemoteCellEdit = function () {
        var remote = _this.props.remote;

        return remote === true || _utils2.default.isObject(remote) && remote.cellEdit;
      }, _this.handleRemotePageChange = function (page, sizePerPage) {
        _this.props.onTableChange('pagination', _this.getNewestState({ page: page, sizePerPage: sizePerPage }));
      }, _this.handleRemoteFilterChange = function (filters) {
        var newState = { filters: filters };
        if (_this.isRemotePagination()) {
          var options = _this.props.pagination.options || {};
          newState.page = _utils2.default.isDefined(options.pageStartIndex) ? options.pageStartIndex : 1;
        }
        _this.props.onTableChange('filter', _this.getNewestState(newState));
      }, _this.handleRemoteSortChange = function (sortField, sortOrder) {
        _this.props.onTableChange('sort', _this.getNewestState({ sortField: sortField, sortOrder: sortOrder }));
      }, _this.handleRemoteCellChange = function (rowId, dataField, newValue) {
        var cellEdit = { rowId: rowId, dataField: dataField, newValue: newValue };
        _this.props.onTableChange('cellEdit', _this.getNewestState({ cellEdit: cellEdit }));
      }, _this.handleRemoteSearchChange = function (searchText) {
        _this.props.onTableChange('search', _this.getNewestState({ searchText: searchText }));
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return RemoteResolver;
  }(ExtendBase);
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _rows = __webpack_require__(6);

var rows = _interopRequireWildcard(_rows);

var _selection = __webpack_require__(7);

var selection = _interopRequireWildcard(_selection);

var _expand = __webpack_require__(40);

var expand = _interopRequireWildcard(_expand);

var _mutate = __webpack_require__(41);

var mutate = _interopRequireWildcard(_mutate);

var _sort = __webpack_require__(42);

var sort = _interopRequireWildcard(_sort);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = _extends({}, rows, selection, expand, mutate, sort);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExpandedRows = exports.expandableKeys = exports.isAnyExpands = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isAnyExpands = exports.isAnyExpands = function isAnyExpands(data, keyField) {
  var expanded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var _loop = function _loop(i) {
    var rowKey = _utils2.default.get(data[i], keyField);
    if (typeof expanded.find(function (x) {
      return x === rowKey;
    }) !== 'undefined') {
      return {
        v: true
      };
    }
  };

  for (var i = 0; i < data.length; i += 1) {
    var _ret = _loop(i);

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }
  return false;
};

var expandableKeys = exports.expandableKeys = function expandableKeys(data, keyField) {
  var skips = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (skips.length === 0) {
    return data.map(function (row) {
      return _utils2.default.get(row, keyField);
    });
  }
  return data.filter(function (row) {
    return !skips.includes(_utils2.default.get(row, keyField));
  }).map(function (row) {
    return _utils2.default.get(row, keyField);
  });
};

var getExpandedRows = exports.getExpandedRows = function getExpandedRows(data, keyField, expanded) {
  return expanded.map(function (k) {
    return (0, _rows.getRowByRowId)(data, keyField, k);
  });
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editCell = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _rows = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var editCell = exports.editCell = function editCell(data, keyField, rowId, dataField, newValue) {
  var row = (0, _rows.getRowByRowId)(data, keyField, rowId);
  if (row) _utils2.default.set(row, dataField, newValue);
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextOrder = exports.sort = undefined;

var _utils = __webpack_require__(3);

var _utils2 = _interopRequireDefault(_utils);

var _const = __webpack_require__(2);

var _const2 = _interopRequireDefault(_const);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* eslint no-nested-ternary: 0 */
/* eslint no-lonely-if: 0 */
/* eslint no-underscore-dangle: 0 */


function comparator(a, b) {
  var result = void 0;
  if (typeof b === 'string') {
    result = b.localeCompare(a);
  } else {
    result = a > b ? -1 : a < b ? 1 : 0;
  }
  return result;
}

var sort = exports.sort = function sort(data, sortOrder, _ref) {
  var dataField = _ref.dataField,
      sortFunc = _ref.sortFunc;

  var _data = [].concat(_toConsumableArray(data));
  _data.sort(function (a, b) {
    var result = void 0;
    var valueA = _utils2.default.get(a, dataField);
    var valueB = _utils2.default.get(b, dataField);
    valueA = _utils2.default.isDefined(valueA) ? valueA : '';
    valueB = _utils2.default.isDefined(valueB) ? valueB : '';

    if (sortFunc) {
      result = sortFunc(valueA, valueB, sortOrder, dataField);
    } else {
      if (sortOrder === _const2.default.SORT_DESC) {
        result = comparator(valueA, valueB);
      } else {
        result = comparator(valueB, valueA);
      }
    }
    return result;
  });
  return _data;
};

var nextOrder = exports.nextOrder = function nextOrder(currentSortColumn, _ref2) {
  var sortOrder = _ref2.sortOrder,
      sortColumn = _ref2.sortColumn;
  var defaultOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const2.default.SORT_DESC;

  if (!sortColumn || currentSortColumn.dataField !== sortColumn.dataField) return defaultOrder;
  return sortOrder === _const2.default.SORT_DESC ? _const2.default.SORT_ASC : _const2.default.SORT_DESC;
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4MTM1MzcxZDA5YTNhOTRkOTExMSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9ib290c3RyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvcm93cy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9ib290c3RyYXAtdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9oZWFkZXItY2VsbC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L2NhcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV4cGFuZC9leHBhbmQtaGVhZGVyLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY2FwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9ib2R5LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jZWxsLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV4cGFuZC9leHBhbmQtY2VsbC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctZXZlbnQtZGVsZWdhdGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1leHBhbmQvZXhwYW5kLXJvdy5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9jb2x1bW4tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcHJvcHMtcmVzb2x2ZXIvZXhwYW5kLXJvdy1yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9kYXRhLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGV4dHMvc29ydC1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnRleHRzL3NlbGVjdGlvbi1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnRleHRzL3Jvdy1leHBhbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9yZW1vdGUtcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvb3BlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL2V4cGFuZC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9tdXRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvc29ydC5qcyJdLCJuYW1lcyI6WyJTT1JUX0FTQyIsIlNPUlRfREVTQyIsIlJPV19TRUxFQ1RfU0lOR0xFIiwiUk9XX1NFTEVDVF9NVUxUSVBMRSIsIlJPV19TRUxFQ1RfRElTQUJMRUQiLCJDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCIsIkNIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFIiwiQ0hFQ0tCT1hfU1RBVFVTX1VOQ0hFQ0tFRCIsInNwbGl0TmVzdGVkIiwic3RyIiwiam9pbiIsInJlcGxhY2UiLCJzcGxpdCIsImdldCIsInRhcmdldCIsImZpZWxkIiwicGF0aEFycmF5IiwicmVzdWx0IiwicmVkdWNlIiwiY3VyciIsInBhdGgiLCJlIiwic2V0IiwidmFsdWUiLCJzYWZlIiwibGV2ZWwiLCJhIiwiYiIsIkVycm9yIiwibGVuZ3RoIiwiaXNFbXB0eU9iamVjdCIsIm9iaiIsImlzT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJrZXlzIiwiaSIsImNhbGwiLCJpc0RlZmluZWQiLCJzbGVlcCIsImZuIiwibXMiLCJzZXRUaW1lb3V0IiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJsYXRlciIsImFwcGx5IiwiY2FsbE5vdyIsImNsZWFyVGltZW91dCIsImFzc2lnbiIsIkJvb3RzdHJhcENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiYm9vdHN0cmFwNCIsIm1hdGNoUm93Iiwia2V5RmllbGQiLCJpZCIsInJvdyIsImdldFJvd0J5Um93SWQiLCJkYXRhIiwiZmluZCIsImdldFNlbGVjdGlvblN1bW1hcnkiLCJzZWxlY3RlZCIsImFsbFJvd3NTZWxlY3RlZCIsImFsbFJvd3NOb3RTZWxlY3RlZCIsInJvd0tleXMiLCJtYXAiLCJkIiwieCIsInNlbGVjdGFibGVLZXlzIiwic2tpcHMiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsInVuU2VsZWN0YWJsZUtleXMiLCJnZXRTZWxlY3RlZFJvd3MiLCJrIiwiQm9vdHN0cmFwVGFibGUiLCJwcm9wcyIsImdldERhdGEiLCJ2YWxpZGF0ZVByb3BzIiwicmVnaXN0ZXJFeHBvc2VkQVBJIiwibG9hZGluZyIsIm92ZXJsYXkiLCJMb2FkaW5nT3ZlcmxheSIsInJlbmRlclRhYmxlIiwiY29sdW1ucyIsImNsYXNzZXMiLCJzdHJpcGVkIiwiaG92ZXIiLCJib3JkZXJlZCIsImNvbmRlbnNlZCIsIm5vRGF0YUluZGljYXRpb24iLCJjYXB0aW9uIiwicm93U3R5bGUiLCJyb3dDbGFzc2VzIiwid3JhcHBlckNsYXNzZXMiLCJyb3dFdmVudHMiLCJ0YWJsZVdyYXBwZXJDbGFzcyIsInRhYmxlQ2xhc3MiLCJjZWxsU2VsZWN0aW9uSW5mbyIsInJlc29sdmVTZWxlY3RSb3dQcm9wcyIsIm9uUm93U2VsZWN0IiwiaGVhZGVyQ2VsbFNlbGVjdGlvbkluZm8iLCJyZXNvbHZlU2VsZWN0Um93UHJvcHNGb3JIZWFkZXIiLCJvbkFsbFJvd3NTZWxlY3QiLCJ0YWJsZUNhcHRpb24iLCJleHBhbmRSb3ciLCJyZXNvbHZlRXhwYW5kUm93UHJvcHMiLCJoZWFkZXJDbGFzc2VzIiwic29ydEZpZWxkIiwic29ydE9yZGVyIiwib25Tb3J0Iiwib25GaWx0ZXIiLCJvbkV4dGVybmFsRmlsdGVyIiwiaXNFbXB0eSIsInZpc2libGVDb2x1bW5TaXplIiwiY2VsbEVkaXQiLCJwcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwiYXJyYXkiLCJib29sIiwicmVtb3RlIiwib25lT2ZUeXBlIiwic2hhcGUiLCJwYWdpbmF0aW9uIiwibm9kZSIsIm9iamVjdCIsInNlbGVjdFJvdyIsIm1vZGUiLCJvbmVPZiIsImNsaWNrVG9TZWxlY3QiLCJjbGlja1RvRWRpdCIsIm9uU2VsZWN0Iiwib25TZWxlY3RBbGwiLCJzdHlsZSIsIm5vblNlbGVjdGFibGUiLCJiZ0NvbG9yIiwiaGlkZVNlbGVjdENvbHVtbiIsInNlbGVjdGlvblJlbmRlcmVyIiwic2VsZWN0aW9uSGVhZGVyUmVuZGVyZXIiLCJyZW5kZXJlciIsImV4cGFuZGVkIiwib25FeHBhbmQiLCJvbkV4cGFuZEFsbCIsIm5vbkV4cGFuZGFibGUiLCJzaG93RXhwYW5kQ29sdW1uIiwiZXhwYW5kQ29sdW1uUmVuZGVyZXIiLCJleHBhbmRIZWFkZXJDb2x1bW5SZW5kZXJlciIsIm9uUm93RXhwYW5kIiwib25BbGxSb3dFeHBhbmQiLCJpc0FueUV4cGFuZHMiLCJkZWZhdWx0U29ydGVkIiwiYXJyYXlPZiIsImRhdGFGaWVsZCIsIm9yZGVyIiwiZGVmYXVsdFNvcnREaXJlY3Rpb24iLCJvblRhYmxlQ2hhbmdlIiwic2VhcmNoIiwic2VhcmNoVGV4dCIsInNlYXJjaENvbnRleHQiLCJzZXREZXBlbmRlbmN5TW9kdWxlcyIsImRlZmF1bHRQcm9wcyIsIkhlYWRlciIsImNsYXNzTmFtZSIsImNvbHVtbiIsImhpZGRlbiIsImN1cnJTb3J0IiwiaXNMYXN0U29ydGluZyIsIkhlYWRlckNlbGwiLCJpbmRleCIsInNvcnRpbmciLCJ0ZXh0Iiwic29ydCIsImZpbHRlclJlbmRlcmVyIiwiaGVhZGVyVGl0bGUiLCJoZWFkZXJBbGlnbiIsImhlYWRlckZvcm1hdHRlciIsImhlYWRlckV2ZW50cyIsImhlYWRlclN0eWxlIiwiaGVhZGVyQXR0cnMiLCJoZWFkZXJTb3J0aW5nQ2xhc3NlcyIsImhlYWRlclNvcnRpbmdTdHlsZSIsImNlbGxBdHRycyIsImlzRnVuY3Rpb24iLCJzb3J0U3ltYm9sIiwiZmlsdGVyRWxtIiwiY2VsbFN0eWxlIiwiY2VsbENsYXNzZXMiLCJ0aXRsZSIsInRleHRBbGlnbiIsImN1c3RvbUNsaWNrIiwib25DbGljayIsIm9uQ3VzdG9tRmlsdGVyIiwidHlwZSIsImNoaWxkcmVuIiwic29ydEVsZW1lbnQiLCJmaWx0ZXJFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImZvcm1hdHRlciIsImZvcm1hdEV4dHJhRGF0YSIsImFueSIsImV2ZW50cyIsImFsaWduIiwiYXR0cnMiLCJzb3J0RnVuYyIsImVkaXRvciIsImVkaXRhYmxlIiwiZWRpdENlbGxTdHlsZSIsImVkaXRDZWxsQ2xhc3NlcyIsImVkaXRvclN0eWxlIiwiZWRpdG9yQ2xhc3NlcyIsImVkaXRvclJlbmRlcmVyIiwidmFsaWRhdG9yIiwiZmlsdGVyVmFsdWUiLCJudW1iZXIiLCJTb3J0U3ltYm9sIiwiU29ydENhcmV0Iiwib3JkZXJDbGFzcyIsImRyb3B1cCIsIkNoZWNrQm94IiwiY2hlY2tlZCIsImluZGV0ZXJtaW5hdGUiLCJpbnB1dCIsIlNlbGVjdGlvbkhlYWRlckNlbGwiLCJoYW5kbGVDaGVja0JveENsaWNrIiwiYmluZCIsIm5leHRQcm9wcyIsImNoZWNrZWRTdGF0dXMiLCJpc1VuU2VsZWN0IiwiY29udGVudCIsImFueUV4cGFuZHMiLCJDYXB0aW9uIiwiQm9keSIsInNlbGVjdGVkUm93S2V5cyIsImluZGljYXRpb24iLCJub25FZGl0YWJsZVJvd3MiLCJrZXkiLCJpbmRleE9mIiwic2VsZWN0ZWRTdHlsZSIsInNlbGVjdGVkQ2xhc3NlcyIsImJhY2tncm91bmRDb2xvciIsInNlbGVjdGFibGUiLCJleHBhbmRhYmxlIiwicHVzaCIsIlJvdyIsInJvd0luZGV4IiwiZWRpdGFibGVSb3ciLCJvblN0YXJ0IiwiRWRpdGluZ0NlbGwiLCJlZGl0aW5nUm93SWR4IiwicmlkeCIsImVkaXRpbmdDb2xJZHgiLCJjaWR4IiwiQ0xJQ0tfVE9fQ0VMTF9FRElUIiwiREJDTElDS19UT19DRUxMX0VESVQiLCJyZXN0IiwidHJBdHRycyIsImRlbGVnYXRlIiwiZWRpdENlbGxzdHlsZSIsImVkaXRDZWxsY2xhc3NlcyIsImNlbGxUaXRsZSIsIkNlbGwiLCJoYW5kbGVFZGl0aW5nQ2VsbCIsInNob3VsZFVwZGF0ZSIsImNvbHVtbkluZGV4IiwiZGJjbGlja1RvRWRpdCIsImlzRXF1YWwiLCJjdXN0b21EYkNsaWNrIiwib25Eb3VibGVDbGljayIsIlNlbGVjdGlvbkNlbGwiLCJoYW5kbGVDbGljayIsImlucHV0VHlwZSIsInJvd0tleSIsImRpc2FibGVkIiwiRXhwYW5kQ2VsbCIsImNsaWNrTnVtIiwiY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlciIsImNyZWF0ZUNsaWNrRXZlbnRIYW5kbGVyIiwiY2IiLCJERUxBWV9GT1JfREJDTElDSyIsImNsaWNrRm4iLCJuZXdBdHRycyIsImZvckVhY2giLCJhdHRyIiwiRXh0ZW5kQmFzZSIsIkV4cGFuZFJvdyIsIlJvd1NlY3Rpb24iLCJjb2xTcGFuIiwib3B0aW9ucyIsImluY2x1ZGVTZWxlY3RDb2x1bW4iLCJjb2x1bW5MZW4iLCJjIiwid2l0aENvbnRleHQiLCJEYXRhQ29udGV4dCIsImNvbCIsIlNvcnRDb250ZXh0IiwiaXNSZW1vdGVTb3J0IiwiaGFuZGxlUmVtb3RlU29ydENoYW5nZSIsIlNlbGVjdGlvbkNvbnRleHQiLCJSb3dFeHBhbmRDb250ZXh0IiwiQ2VsbEVkaXRDb250ZXh0IiwiaXNSZW1vdGVDZWxsRWRpdCIsImhhbmRsZVJlbW90ZUNlbGxDaGFuZ2UiLCJGaWx0ZXJDb250ZXh0IiwiaXNSZW1vdGVGaWx0ZXJpbmciLCJoYW5kbGVSZW1vdGVGaWx0ZXJDaGFuZ2UiLCJQYWdpbmF0aW9uQ29udGV4dCIsImlzUmVtb3RlUGFnaW5hdGlvbiIsImhhbmRsZVJlbW90ZVBhZ2VDaGFuZ2UiLCJTZWFyY2hDb250ZXh0IiwiaXNSZW1vdGVTZWFyY2giLCJoYW5kbGVSZW1vdGVTZWFyY2hDaGFuZ2UiLCJyb290UHJvcHMiLCJjZWxsRWRpdFByb3BzIiwiZmlsdGVyUHJvcHMiLCJzZWFyY2hQcm9wcyIsInNvcnRQcm9wcyIsInBhZ2luYXRpb25Qcm9wcyIsImV4cGFuZFByb3BzIiwic2VsZWN0aW9uUHJvcHMiLCJiYXNlIiwiYmFzZVByb3BzIiwicGFnaW5hdGlvbkNvbnRleHQiLCJuIiwic29ydENvbnRleHQiLCJmaWx0ZXJDb250ZXh0IiwicmVuZGVyQmFzZSIsInJlbmRlcldpdGhTZWxlY3Rpb25DdHgiLCJyZW5kZXJXaXRoUm93RXhwYW5kQ3R4IiwicmVuZGVyV2l0aFBhZ2luYXRpb25DdHgiLCJyZW5kZXJXaXRoU29ydEN0eCIsInJlbmRlcldpdGhTZWFyY2hDdHgiLCJyZW5kZXJXaXRoRmlsdGVyQ3R4IiwicmVuZGVyV2l0aENlbGxFZGl0Q3R4IiwiRGF0YVByb3ZpZGVyIiwic3RhdGUiLCJzZXRTdGF0ZSIsIlByb3ZpZGVyIiwiQ29uc3VtZXIiLCJkYXRhT3BlcmF0b3IiLCJoYW5kbGVTb3J0Q2hhbmdlIiwiU29ydFByb3ZpZGVyIiwic29ydENvbHVtbiIsInNvcnRDb2x1bW5zIiwiaGFuZGxlU29ydCIsIkNvbXBvbmVudCIsIm5leHRPcmRlciIsIlNlbGVjdGlvblByb3ZpZGVyIiwiaGFuZGxlUm93U2VsZWN0IiwiY3VyclNlbGVjdGVkIiwiaGFuZGxlQWxsUm93c1NlbGVjdCIsImNvbmNhdCIsInMiLCJSb3dFeHBhbmRQcm92aWRlciIsImhhbmRsZVJvd0V4cGFuZCIsImN1cnJFeHBhbmRlZCIsImhhbmRsZUFsbFJvd0V4cGFuZCIsImV4cGFuZEFsbCIsImV4cGFuZGFibGVLZXlzIiwiZ2V0RXhwYW5kZWRSb3dzIiwiZ2V0TmV3ZXN0U3RhdGUiLCJwYWdlIiwic2l6ZVBlclBhZ2UiLCJmaWx0ZXJzIiwiY3VyckZpbHRlcnMiLCJjdXJyUGFnZSIsImN1cnJTaXplUGVyUGFnZSIsIm5ld1N0YXRlIiwicGFnZVN0YXJ0SW5kZXgiLCJyb3dJZCIsIm5ld1ZhbHVlIiwicm93cyIsInNlbGVjdGlvbiIsImV4cGFuZCIsIm11dGF0ZSIsImVkaXRDZWxsIiwiY29tcGFyYXRvciIsImxvY2FsZUNvbXBhcmUiLCJfZGF0YSIsInZhbHVlQSIsInZhbHVlQiIsImN1cnJlbnRTb3J0Q29sdW1uIiwiZGVmYXVsdE9yZGVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBLCtDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztrQkM3QmU7QUFDYkEsWUFBVSxLQURHO0FBRWJDLGFBQVcsTUFGRTtBQUdiQyxxQkFBbUIsT0FITjtBQUliQyx1QkFBcUIsVUFKUjtBQUtiQyx1QkFBcUIscUJBTFI7QUFNYkMsMkJBQXlCLFNBTlo7QUFPYkMsaUNBQStCLGVBUGxCO0FBUWJDLDZCQUEyQjtBQVJkLEM7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQixFQUFFO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdEQUFnRCxtQ0FBbUM7QUFDbkYsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwrQ0FBK0MsbUNBQW1DO0FBQ2xGLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQ0FBaUMsRUFBRTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEIsRUFBRTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0IsRUFBRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUFBeUIvUSxTQUF6QixFQUFvQzRDLFNBQXBDLENBQVQ7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJNUMsY0FBYyxnQkFBTWhILFNBQXhCLEVBQW1DO0FBQ2pDZ0IsaUJBQVMyVyxXQUFXRyxNQUFYLEVBQW1CQyxNQUFuQixDQUFUO0FBQ0QsT0FGRCxNQUVPO0FBQ0wvVyxpQkFBUzJXLFdBQVdJLE1BQVgsRUFBbUJELE1BQW5CLENBQVQ7QUFDRDtBQUNGO0FBQ0QsV0FBTzlXLE1BQVA7QUFDRCxHQWpCRDtBQWtCQSxTQUFPNlcsS0FBUDtBQUNELENBckJNOztBQXVCQSxJQUFNaEMsZ0NBQVksU0FBWkEsU0FBWSxDQUN2Qm1DLGlCQUR1QixTQUlwQjtBQUFBLE1BRkRoUixTQUVDLFNBRkRBLFNBRUM7QUFBQSxNQUZVeU8sVUFFVixTQUZVQSxVQUVWO0FBQUEsTUFESHdDLFlBQ0csdUVBRFksZ0JBQU1qWSxTQUNsQjs7QUFDSCxNQUFJLENBQUN5VixVQUFELElBQWV1QyxrQkFBa0JwTyxTQUFsQixLQUFnQzZMLFdBQVc3TCxTQUE5RCxFQUF5RSxPQUFPcU8sWUFBUDtBQUN6RSxTQUFPalIsY0FBYyxnQkFBTWhILFNBQXBCLEdBQWdDLGdCQUFNRCxRQUF0QyxHQUFpRCxnQkFBTUMsU0FBOUQ7QUFDRCxDQVBNLEMiLCJmaWxlIjoicmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9kaXN0L3JlYWN0LWJvb3RzdHJhcC10YWJsZS1uZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmVhY3RCb290c3RyYXBUYWJsZTJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmVhY3RCb290c3RyYXBUYWJsZTJcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA4MTM1MzcxZDA5YTNhOTRkOTExMSIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZXhwb3J0IGRlZmF1bHQge1xuICBTT1JUX0FTQzogJ2FzYycsXG4gIFNPUlRfREVTQzogJ2Rlc2MnLFxuICBST1dfU0VMRUNUX1NJTkdMRTogJ3JhZGlvJyxcbiAgUk9XX1NFTEVDVF9NVUxUSVBMRTogJ2NoZWNrYm94JyxcbiAgUk9XX1NFTEVDVF9ESVNBQkxFRDogJ1JPV19TRUxFQ1RfRElTQUJMRUQnLFxuICBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRDogJ2NoZWNrZWQnLFxuICBDSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURTogJ2luZGV0ZXJtaW5hdGUnLFxuICBDSEVDS0JPWF9TVEFUVVNfVU5DSEVDS0VEOiAndW5jaGVja2VkJ1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnN0LmpzIiwiLyogZXNsaW50IG5vLWVtcHR5OiAwICovXG4vKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbi8qIGVzbGludCBwcmVmZXItcmVzdC1wYXJhbXM6IDAgKi9cbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG5mdW5jdGlvbiBzcGxpdE5lc3RlZChzdHIpIHtcbiAgcmV0dXJuIFtzdHJdXG4gICAgLmpvaW4oJy4nKVxuICAgIC5yZXBsYWNlKC9cXFsvZywgJy4nKVxuICAgIC5yZXBsYWNlKC9cXF0vZywgJycpXG4gICAgLnNwbGl0KCcuJyk7XG59XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIGZpZWxkKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IHNwbGl0TmVzdGVkKGZpZWxkKTtcbiAgbGV0IHJlc3VsdDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBwYXRoQXJyYXkucmVkdWNlKChjdXJyLCBwYXRoKSA9PiBjdXJyW3BhdGhdLCB0YXJnZXQpO1xuICB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBmaWVsZCwgdmFsdWUsIHNhZmUgPSBmYWxzZSkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBzcGxpdE5lc3RlZChmaWVsZCk7XG4gIGxldCBsZXZlbCA9IDA7XG4gIHBhdGhBcnJheS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICBsZXZlbCArPSAxO1xuICAgIGlmICh0eXBlb2YgYVtiXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICghc2FmZSkgdGhyb3cgbmV3IEVycm9yKGAke2F9LiR7Yn0gaXMgdW5kZWZpbmVkYCk7XG4gICAgICBhW2JdID0ge307XG4gICAgICByZXR1cm4gYVtiXTtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWwgPT09IHBhdGhBcnJheS5sZW5ndGgpIHtcbiAgICAgIGFbYl0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFbYl07XG4gIH0sIHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKSB7XG4gIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBzbGVlcChmbiwgbXMpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gZm4oKSwgbXMpO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgbGV0IHRpbWVvdXQ7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuXG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgfHwgMCk7XG5cbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmFzc2lnbihfLCB7IGdldCwgc2V0LCBpc0RlZmluZWQsIGlzRW1wdHlPYmplY3QsIHNsZWVwLCBkZWJvdW5jZSB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3V0aWxzLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IEJvb3RzdHJhcENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYm9vdHN0cmFwNDogZmFsc2Vcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGV4dHMvYm9vdHN0cmFwLmpzIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXG5leHBvcnQgY29uc3QgbWF0Y2hSb3cgPSAoa2V5RmllbGQsIGlkKSA9PiByb3cgPT4gcm93W2tleUZpZWxkXSA9PT0gaWQ7XG5cbmV4cG9ydCBjb25zdCBnZXRSb3dCeVJvd0lkID0gKGRhdGEsIGtleUZpZWxkLCBpZCkgPT4gZGF0YS5maW5kKG1hdGNoUm93KGtleUZpZWxkLCBpZCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvcm93cy5qcyIsImltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFJvd0J5Um93SWQgfSBmcm9tICcuL3Jvd3MnO1xuXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0aW9uU3VtbWFyeSA9IChcbiAgZGF0YSxcbiAga2V5RmllbGQsXG4gIHNlbGVjdGVkID0gW11cbikgPT4ge1xuICBsZXQgYWxsUm93c1NlbGVjdGVkID0gdHJ1ZTtcbiAgbGV0IGFsbFJvd3NOb3RTZWxlY3RlZCA9IHRydWU7XG5cbiAgY29uc3Qgcm93S2V5cyA9IGRhdGEubWFwKGQgPT4gZFtrZXlGaWVsZF0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0tleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjdXJyID0gcm93S2V5c1tpXTtcbiAgICBpZiAodHlwZW9mIHNlbGVjdGVkLmZpbmQoeCA9PiB4ID09PSBjdXJyKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFsbFJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGxSb3dzTm90U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbGxSb3dzU2VsZWN0ZWQsXG4gICAgYWxsUm93c05vdFNlbGVjdGVkXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2VsZWN0YWJsZUtleXMgPSAoZGF0YSwga2V5RmllbGQsIHNraXBzID0gW10pID0+IHtcbiAgaWYgKHNraXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhLm1hcChyb3cgPT4gXy5nZXQocm93LCBrZXlGaWVsZCkpO1xuICB9XG4gIHJldHVybiBkYXRhXG4gICAgLmZpbHRlcihyb3cgPT4gIXNraXBzLmluY2x1ZGVzKF8uZ2V0KHJvdywga2V5RmllbGQpKSlcbiAgICAubWFwKHJvdyA9PiBfLmdldChyb3csIGtleUZpZWxkKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdW5TZWxlY3RhYmxlS2V5cyA9IChzZWxlY3RlZCwgc2tpcHMgPSBbXSkgPT4ge1xuICBpZiAoc2tpcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZC5maWx0ZXIoeCA9PiBza2lwcy5pbmNsdWRlcyh4KSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0ZWRSb3dzID0gKGRhdGEsIGtleUZpZWxkLCBzZWxlY3RlZCkgPT5cbiAgc2VsZWN0ZWQubWFwKGsgPT4gZ2V0Um93QnlSb3dJZChkYXRhLCBrZXlGaWVsZCwgaykpO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9zZWxlY3Rpb24uanMiLCJpbXBvcnQgQm9vdHN0cmFwVGFibGUgZnJvbSAnLi9zcmMvYm9vdHN0cmFwLXRhYmxlJztcbmltcG9ydCB3aXRoQ29udGV4dCBmcm9tICcuL3NyYy9jb250ZXh0cyc7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhDb250ZXh0KEJvb3RzdHJhcFRhYmxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvaW5kZXguanMiLCIvKiBlc2xpbnQgYXJyb3ctYm9keS1zdHlsZTogMCAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IEhlYWRlciBmcm9tICcuL2hlYWRlcic7XG5pbXBvcnQgQ2FwdGlvbiBmcm9tICcuL2NhcHRpb24nO1xuaW1wb3J0IEJvZHkgZnJvbSAnLi9ib2R5JztcbmltcG9ydCBQcm9wc0Jhc2VSZXNvbHZlciBmcm9tICcuL3Byb3BzLXJlc29sdmVyJztcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcbmltcG9ydCB7IGdldFNlbGVjdGlvblN1bW1hcnkgfSBmcm9tICcuL3N0b3JlL3NlbGVjdGlvbic7XG5cbmNsYXNzIEJvb3RzdHJhcFRhYmxlIGV4dGVuZHMgUHJvcHNCYXNlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMudmFsaWRhdGVQcm9wcygpO1xuICAgIGlmIChwcm9wcy5yZWdpc3RlckV4cG9zZWRBUEkpIHtcbiAgICAgIGNvbnN0IGdldERhdGEgPSAoKSA9PiB0aGlzLmdldERhdGEoKTtcbiAgICAgIHByb3BzLnJlZ2lzdGVyRXhwb3NlZEFQSShnZXREYXRhKTtcbiAgICB9XG4gIH1cblxuICAvLyBFeHBvc2VkIEFQSXNcbiAgZ2V0RGF0YSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5kYXRhO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbG9hZGluZywgb3ZlcmxheSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob3ZlcmxheSkge1xuICAgICAgY29uc3QgTG9hZGluZ092ZXJsYXkgPSBvdmVybGF5KGxvYWRpbmcpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPExvYWRpbmdPdmVybGF5PlxuICAgICAgICAgIHsgdGhpcy5yZW5kZXJUYWJsZSgpIH1cbiAgICAgICAgPC9Mb2FkaW5nT3ZlcmxheT5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlclRhYmxlKCk7XG4gIH1cblxuICByZW5kZXJUYWJsZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgY29sdW1ucyxcbiAgICAgIGtleUZpZWxkLFxuICAgICAgaWQsXG4gICAgICBjbGFzc2VzLFxuICAgICAgc3RyaXBlZCxcbiAgICAgIGhvdmVyLFxuICAgICAgYm9yZGVyZWQsXG4gICAgICBjb25kZW5zZWQsXG4gICAgICBub0RhdGFJbmRpY2F0aW9uLFxuICAgICAgY2FwdGlvbixcbiAgICAgIHJvd1N0eWxlLFxuICAgICAgcm93Q2xhc3NlcyxcbiAgICAgIHdyYXBwZXJDbGFzc2VzLFxuICAgICAgcm93RXZlbnRzLFxuICAgICAgc2VsZWN0ZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHRhYmxlV3JhcHBlckNsYXNzID0gY3MoJ3JlYWN0LWJvb3RzdHJhcC10YWJsZScsIHdyYXBwZXJDbGFzc2VzKTtcblxuICAgIGNvbnN0IHRhYmxlQ2xhc3MgPSBjcygndGFibGUnLCB7XG4gICAgICAndGFibGUtc3RyaXBlZCc6IHN0cmlwZWQsXG4gICAgICAndGFibGUtaG92ZXInOiBob3ZlcixcbiAgICAgICd0YWJsZS1ib3JkZXJlZCc6IGJvcmRlcmVkLFxuICAgICAgJ3RhYmxlLWNvbmRlbnNlZCc6IGNvbmRlbnNlZFxuICAgIH0sIGNsYXNzZXMpO1xuXG4gICAgY29uc3QgY2VsbFNlbGVjdGlvbkluZm8gPSB0aGlzLnJlc29sdmVTZWxlY3RSb3dQcm9wcyh7XG4gICAgICBvblJvd1NlbGVjdDogdGhpcy5wcm9wcy5vblJvd1NlbGVjdFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBhbGxSb3dzU2VsZWN0ZWQsIGFsbFJvd3NOb3RTZWxlY3RlZCB9ID0gZ2V0U2VsZWN0aW9uU3VtbWFyeShkYXRhLCBrZXlGaWVsZCwgc2VsZWN0ZWQpO1xuICAgIGNvbnN0IGhlYWRlckNlbGxTZWxlY3Rpb25JbmZvID0gdGhpcy5yZXNvbHZlU2VsZWN0Um93UHJvcHNGb3JIZWFkZXIoe1xuICAgICAgb25BbGxSb3dzU2VsZWN0OiB0aGlzLnByb3BzLm9uQWxsUm93c1NlbGVjdCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgYWxsUm93c1NlbGVjdGVkLFxuICAgICAgYWxsUm93c05vdFNlbGVjdGVkXG4gICAgfSk7XG5cbiAgICBjb25zdCB0YWJsZUNhcHRpb24gPSAoY2FwdGlvbiAmJiA8Q2FwdGlvbj57IGNhcHRpb24gfTwvQ2FwdGlvbj4pO1xuICAgIGNvbnN0IGV4cGFuZFJvdyA9IHRoaXMucmVzb2x2ZUV4cGFuZFJvd1Byb3BzKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9eyB0YWJsZVdyYXBwZXJDbGFzcyB9PlxuICAgICAgICA8dGFibGUgaWQ9eyBpZCB9IGNsYXNzTmFtZT17IHRhYmxlQ2xhc3MgfT5cbiAgICAgICAgICB7IHRhYmxlQ2FwdGlvbiB9XG4gICAgICAgICAgPEhlYWRlclxuICAgICAgICAgICAgY29sdW1ucz17IGNvbHVtbnMgfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXsgdGhpcy5wcm9wcy5oZWFkZXJDbGFzc2VzIH1cbiAgICAgICAgICAgIHNvcnRGaWVsZD17IHRoaXMucHJvcHMuc29ydEZpZWxkIH1cbiAgICAgICAgICAgIHNvcnRPcmRlcj17IHRoaXMucHJvcHMuc29ydE9yZGVyIH1cbiAgICAgICAgICAgIG9uU29ydD17IHRoaXMucHJvcHMub25Tb3J0IH1cbiAgICAgICAgICAgIG9uRmlsdGVyPXsgdGhpcy5wcm9wcy5vbkZpbHRlciB9XG4gICAgICAgICAgICBvbkV4dGVybmFsRmlsdGVyPXsgdGhpcy5wcm9wcy5vbkV4dGVybmFsRmlsdGVyIH1cbiAgICAgICAgICAgIHNlbGVjdFJvdz17IGhlYWRlckNlbGxTZWxlY3Rpb25JbmZvIH1cbiAgICAgICAgICAgIGV4cGFuZFJvdz17IGV4cGFuZFJvdyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8Qm9keVxuICAgICAgICAgICAgZGF0YT17IGRhdGEgfVxuICAgICAgICAgICAga2V5RmllbGQ9eyBrZXlGaWVsZCB9XG4gICAgICAgICAgICBjb2x1bW5zPXsgY29sdW1ucyB9XG4gICAgICAgICAgICBpc0VtcHR5PXsgdGhpcy5pc0VtcHR5KCkgfVxuICAgICAgICAgICAgdmlzaWJsZUNvbHVtblNpemU9eyB0aGlzLnZpc2libGVDb2x1bW5TaXplKCkgfVxuICAgICAgICAgICAgbm9EYXRhSW5kaWNhdGlvbj17IG5vRGF0YUluZGljYXRpb24gfVxuICAgICAgICAgICAgY2VsbEVkaXQ9eyB0aGlzLnByb3BzLmNlbGxFZGl0IHx8IHt9IH1cbiAgICAgICAgICAgIHNlbGVjdFJvdz17IGNlbGxTZWxlY3Rpb25JbmZvIH1cbiAgICAgICAgICAgIHNlbGVjdGVkUm93S2V5cz17IHNlbGVjdGVkIH1cbiAgICAgICAgICAgIGV4cGFuZFJvdz17IGV4cGFuZFJvdyB9XG4gICAgICAgICAgICByb3dTdHlsZT17IHJvd1N0eWxlIH1cbiAgICAgICAgICAgIHJvd0NsYXNzZXM9eyByb3dDbGFzc2VzIH1cbiAgICAgICAgICAgIHJvd0V2ZW50cz17IHJvd0V2ZW50cyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC90YWJsZT5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuQm9vdHN0cmFwVGFibGUucHJvcFR5cGVzID0ge1xuICBrZXlGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGJvb3RzdHJhcDQ6IFByb3BUeXBlcy5ib29sLFxuICByZW1vdGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHBhZ2luYXRpb246IFByb3BUeXBlcy5ib29sXG4gIH0pXSksXG4gIG5vRGF0YUluZGljYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gIHN0cmlwZWQ6IFByb3BUeXBlcy5ib29sLFxuICBib3JkZXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGhvdmVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdyYXBwZXJDbGFzc2VzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb25kZW5zZWQ6IFByb3BUeXBlcy5ib29sLFxuICBjYXB0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubm9kZSxcbiAgICBQcm9wVHlwZXMuc3RyaW5nXG4gIF0pLFxuICBwYWdpbmF0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBmaWx0ZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gIGNlbGxFZGl0OiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RSb3c6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFtDb25zdC5ST1dfU0VMRUNUX1NJTkdMRSwgQ29uc3QuUk9XX1NFTEVDVF9NVUxUSVBMRV0pLmlzUmVxdWlyZWQsXG4gICAgY2xpY2tUb1NlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xpY2tUb0VkaXQ6IFByb3BUeXBlcy5ib29sLFxuICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNlbGVjdEFsbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgY2xhc3NlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBub25TZWxlY3RhYmxlOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgYmdDb2xvcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoaWRlU2VsZWN0Q29sdW1uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzZWxlY3Rpb25SZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2VsZWN0aW9uSGVhZGVyUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jXG4gIH0pLFxuICBvblJvd1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQWxsUm93c1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIGV4cGFuZFJvdzogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICByZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBleHBhbmRlZDogUHJvcFR5cGVzLmFycmF5LFxuICAgIG9uRXhwYW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkV4cGFuZEFsbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgbm9uRXhwYW5kYWJsZTogUHJvcFR5cGVzLmFycmF5LFxuICAgIHNob3dFeHBhbmRDb2x1bW46IFByb3BUeXBlcy5ib29sLFxuICAgIGV4cGFuZENvbHVtblJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBleHBhbmRIZWFkZXJDb2x1bW5SZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmNcbiAgfSksXG4gIG9uUm93RXhwYW5kOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25BbGxSb3dFeHBhbmQ6IFByb3BUeXBlcy5mdW5jLFxuICBpc0FueUV4cGFuZHM6IFByb3BUeXBlcy5ib29sLFxuICByb3dTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgcm93RXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICByb3dDbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICBoZWFkZXJDbGFzc2VzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkZWZhdWx0U29ydGVkOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGRhdGFGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfREVTQywgQ29uc3QuU09SVF9BU0NdKS5pc1JlcXVpcmVkXG4gIH0pKSxcbiAgZGVmYXVsdFNvcnREaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuU09SVF9ERVNDLCBDb25zdC5TT1JUX0FTQ10pLFxuICBvdmVybGF5OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UYWJsZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FeHRlcm5hbEZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIEluamVjdCBmcm9tIHRvb2xraXRcbiAgc2VhcmNoOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHNlYXJjaFRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgc2VhcmNoQ29udGV4dDogUHJvcFR5cGVzLmZ1bmNcbiAgfSksXG4gIHNldERlcGVuZGVuY3lNb2R1bGVzOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuQm9vdHN0cmFwVGFibGUuZGVmYXVsdFByb3BzID0ge1xuICBib290c3RyYXA0OiBmYWxzZSxcbiAgcmVtb3RlOiBmYWxzZSxcbiAgc3RyaXBlZDogZmFsc2UsXG4gIGJvcmRlcmVkOiB0cnVlLFxuICBob3ZlcjogZmFsc2UsXG4gIGNvbmRlbnNlZDogZmFsc2UsXG4gIG5vRGF0YUluZGljYXRpb246IG51bGxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJvb3RzdHJhcFRhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvYm9vdHN0cmFwLXRhYmxlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5pbXBvcnQgSGVhZGVyQ2VsbCBmcm9tICcuL2hlYWRlci1jZWxsJztcbmltcG9ydCBTZWxlY3Rpb25IZWFkZXJDZWxsIGZyb20gJy4vcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24taGVhZGVyLWNlbGwnO1xuaW1wb3J0IEV4cGFuZEhlYWRlckNlbGwgZnJvbSAnLi9yb3ctZXhwYW5kL2V4cGFuZC1oZWFkZXItY2VsbCc7XG5cbmNvbnN0IEhlYWRlciA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IFJPV19TRUxFQ1RfRElTQUJMRUQgfSA9IENvbnN0O1xuXG4gIGNvbnN0IHtcbiAgICBjbGFzc05hbWUsXG4gICAgY29sdW1ucyxcbiAgICBvblNvcnQsXG4gICAgb25GaWx0ZXIsXG4gICAgc29ydEZpZWxkLFxuICAgIHNvcnRPcmRlcixcbiAgICBzZWxlY3RSb3csXG4gICAgb25FeHRlcm5hbEZpbHRlcixcbiAgICBleHBhbmRSb3csXG4gICAgYm9vdHN0cmFwNFxuICB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8dGhlYWQ+XG4gICAgICA8dHIgY2xhc3NOYW1lPXsgY2xhc3NOYW1lIH0+XG4gICAgICAgIHtcbiAgICAgICAgICAoZXhwYW5kUm93ICYmIGV4cGFuZFJvdy5zaG93RXhwYW5kQ29sdW1uKVxuICAgICAgICAgICAgPyA8RXhwYW5kSGVhZGVyQ2VsbFxuICAgICAgICAgICAgICBvbkFsbFJvd0V4cGFuZD17IGV4cGFuZFJvdy5vbkFsbFJvd0V4cGFuZCB9XG4gICAgICAgICAgICAgIGFueUV4cGFuZHM9eyBleHBhbmRSb3cuaXNBbnlFeHBhbmRzIH1cbiAgICAgICAgICAgICAgcmVuZGVyZXI9eyBleHBhbmRSb3cuZXhwYW5kSGVhZGVyQ29sdW1uUmVuZGVyZXIgfVxuICAgICAgICAgICAgLz4gOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIChzZWxlY3RSb3cubW9kZSAhPT0gUk9XX1NFTEVDVF9ESVNBQkxFRCAmJiAhc2VsZWN0Um93LmhpZGVTZWxlY3RDb2x1bW4pXG4gICAgICAgICAgICA/IDxTZWxlY3Rpb25IZWFkZXJDZWxsIHsgLi4uc2VsZWN0Um93IH0gLz4gOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbHVtbnMubWFwKChjb2x1bW4sIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghY29sdW1uLmhpZGRlbikge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyU29ydCA9IGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRGaWVsZDtcbiAgICAgICAgICAgICAgY29uc3QgaXNMYXN0U29ydGluZyA9IGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRGaWVsZDtcblxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxIZWFkZXJDZWxsXG4gICAgICAgICAgICAgICAgICBpbmRleD17IGkgfVxuICAgICAgICAgICAgICAgICAgYm9vdHN0cmFwND17IGJvb3RzdHJhcDQgfVxuICAgICAgICAgICAgICAgICAga2V5PXsgY29sdW1uLmRhdGFGaWVsZCB9XG4gICAgICAgICAgICAgICAgICBjb2x1bW49eyBjb2x1bW4gfVxuICAgICAgICAgICAgICAgICAgb25Tb3J0PXsgb25Tb3J0IH1cbiAgICAgICAgICAgICAgICAgIHNvcnRpbmc9eyBjdXJyU29ydCB9XG4gICAgICAgICAgICAgICAgICBvbkZpbHRlcj17IG9uRmlsdGVyIH1cbiAgICAgICAgICAgICAgICAgIG9uRXh0ZXJuYWxGaWx0ZXI9eyBvbkV4dGVybmFsRmlsdGVyIH1cbiAgICAgICAgICAgICAgICAgIHNvcnRPcmRlcj17IHNvcnRPcmRlciB9XG4gICAgICAgICAgICAgICAgICBpc0xhc3RTb3J0aW5nPXsgaXNMYXN0U29ydGluZyB9XG4gICAgICAgICAgICAgICAgLz4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIDwvdHI+XG4gICAgPC90aGVhZD5cbiAgKTtcbn07XG5cbkhlYWRlci5wcm9wVHlwZXMgPSB7XG4gIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkZpbHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvcnRGaWVsZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgc29ydE9yZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzZWxlY3RSb3c6IFByb3BUeXBlcy5vYmplY3QsXG4gIG9uRXh0ZXJuYWxGaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4cGFuZFJvdzogUHJvcFR5cGVzLm9iamVjdCxcbiAgYm9vdHN0cmFwNDogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2hlYWRlci5qcyIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5pbXBvcnQgU29ydFN5bWJvbCBmcm9tICcuL3NvcnQvc3ltYm9sJztcbmltcG9ydCBTb3J0Q2FyZXQgZnJvbSAnLi9zb3J0L2NhcmV0JztcbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuXG5cbmNvbnN0IEhlYWRlckNlbGwgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbHVtbixcbiAgICBpbmRleCxcbiAgICBvblNvcnQsXG4gICAgc29ydGluZyxcbiAgICBzb3J0T3JkZXIsXG4gICAgaXNMYXN0U29ydGluZyxcbiAgICBvbkZpbHRlcixcbiAgICBvbkV4dGVybmFsRmlsdGVyXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCB7XG4gICAgdGV4dCxcbiAgICBzb3J0LFxuICAgIGZpbHRlcixcbiAgICBmaWx0ZXJSZW5kZXJlcixcbiAgICBoZWFkZXJUaXRsZSxcbiAgICBoZWFkZXJBbGlnbixcbiAgICBoZWFkZXJGb3JtYXR0ZXIsXG4gICAgaGVhZGVyRXZlbnRzLFxuICAgIGhlYWRlckNsYXNzZXMsXG4gICAgaGVhZGVyU3R5bGUsXG4gICAgaGVhZGVyQXR0cnMsXG4gICAgaGVhZGVyU29ydGluZ0NsYXNzZXMsXG4gICAgaGVhZGVyU29ydGluZ1N0eWxlXG4gIH0gPSBjb2x1bW47XG5cbiAgY29uc3QgY2VsbEF0dHJzID0ge1xuICAgIC4uLl8uaXNGdW5jdGlvbihoZWFkZXJBdHRycykgPyBoZWFkZXJBdHRycyhjb2x1bW4sIGluZGV4KSA6IGhlYWRlckF0dHJzLFxuICAgIC4uLmhlYWRlckV2ZW50c1xuICB9O1xuXG4gIGxldCBzb3J0U3ltYm9sO1xuICBsZXQgZmlsdGVyRWxtO1xuICBsZXQgY2VsbFN0eWxlID0ge307XG4gIGxldCBjZWxsQ2xhc3NlcyA9IF8uaXNGdW5jdGlvbihoZWFkZXJDbGFzc2VzKSA/IGhlYWRlckNsYXNzZXMoY29sdW1uLCBpbmRleCkgOiBoZWFkZXJDbGFzc2VzO1xuXG4gIGlmIChoZWFkZXJTdHlsZSkge1xuICAgIGNlbGxTdHlsZSA9IF8uaXNGdW5jdGlvbihoZWFkZXJTdHlsZSkgPyBoZWFkZXJTdHlsZShjb2x1bW4sIGluZGV4KSA6IGhlYWRlclN0eWxlO1xuICB9XG5cbiAgaWYgKGhlYWRlclRpdGxlKSB7XG4gICAgY2VsbEF0dHJzLnRpdGxlID0gXy5pc0Z1bmN0aW9uKGhlYWRlclRpdGxlKSA/IGhlYWRlclRpdGxlKGNvbHVtbiwgaW5kZXgpIDogdGV4dDtcbiAgfVxuXG4gIGlmIChoZWFkZXJBbGlnbikge1xuICAgIGNlbGxTdHlsZS50ZXh0QWxpZ24gPSBfLmlzRnVuY3Rpb24oaGVhZGVyQWxpZ24pID8gaGVhZGVyQWxpZ24oY29sdW1uLCBpbmRleCkgOiBoZWFkZXJBbGlnbjtcbiAgfVxuXG4gIGlmIChzb3J0KSB7XG4gICAgY29uc3QgY3VzdG9tQ2xpY2sgPSBjZWxsQXR0cnMub25DbGljaztcbiAgICBjZWxsQXR0cnMub25DbGljayA9IChlKSA9PiB7XG4gICAgICBvblNvcnQoY29sdW1uKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tQ2xpY2spKSBjdXN0b21DbGljayhlKTtcbiAgICB9O1xuICAgIGNlbGxBdHRycy5jbGFzc05hbWUgPSBjcyhjZWxsQXR0cnMuY2xhc3NOYW1lLCAnc29ydGFibGUnKTtcblxuICAgIGlmIChzb3J0aW5nKSB7XG4gICAgICBzb3J0U3ltYm9sID0gPFNvcnRDYXJldCBvcmRlcj17IHNvcnRPcmRlciB9IC8+O1xuXG4gICAgICAvLyBhcHBlbmQgY3VzdG9taXplZCBjbGFzc2VzIG9yIHN0eWxlIGlmIHRhYmxlIHdhcyBzb3J0aW5nIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNvbHVtbi5cbiAgICAgIGNlbGxDbGFzc2VzID0gY3MoXG4gICAgICAgIGNlbGxDbGFzc2VzLFxuICAgICAgICBfLmlzRnVuY3Rpb24oaGVhZGVyU29ydGluZ0NsYXNzZXMpXG4gICAgICAgICAgPyBoZWFkZXJTb3J0aW5nQ2xhc3Nlcyhjb2x1bW4sIHNvcnRPcmRlciwgaXNMYXN0U29ydGluZywgaW5kZXgpXG4gICAgICAgICAgOiBoZWFkZXJTb3J0aW5nQ2xhc3Nlc1xuICAgICAgKTtcblxuICAgICAgY2VsbFN0eWxlID0ge1xuICAgICAgICAuLi5jZWxsU3R5bGUsXG4gICAgICAgIC4uLl8uaXNGdW5jdGlvbihoZWFkZXJTb3J0aW5nU3R5bGUpXG4gICAgICAgICAgPyBoZWFkZXJTb3J0aW5nU3R5bGUoY29sdW1uLCBzb3J0T3JkZXIsIGlzTGFzdFNvcnRpbmcsIGluZGV4KVxuICAgICAgICAgIDogaGVhZGVyU29ydGluZ1N0eWxlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3J0U3ltYm9sID0gPFNvcnRTeW1ib2wgLz47XG4gICAgfVxuICB9XG5cbiAgaWYgKGNlbGxDbGFzc2VzKSBjZWxsQXR0cnMuY2xhc3NOYW1lID0gY3MoY2VsbEF0dHJzLmNsYXNzTmFtZSwgY2VsbENsYXNzZXMpO1xuICBpZiAoIV8uaXNFbXB0eU9iamVjdChjZWxsU3R5bGUpKSBjZWxsQXR0cnMuc3R5bGUgPSBjZWxsU3R5bGU7XG5cbiAgaWYgKGZpbHRlclJlbmRlcmVyKSB7XG4gICAgY29uc3Qgb25DdXN0b21GaWx0ZXIgPSBvbkV4dGVybmFsRmlsdGVyKGNvbHVtbiwgZmlsdGVyLnByb3BzLnR5cGUpO1xuICAgIGZpbHRlckVsbSA9IGZpbHRlclJlbmRlcmVyKG9uQ3VzdG9tRmlsdGVyLCBjb2x1bW4pO1xuICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgIGZpbHRlckVsbSA9IDxmaWx0ZXIuRmlsdGVyIHsgLi4uZmlsdGVyLnByb3BzIH0gb25GaWx0ZXI9eyBvbkZpbHRlciB9IGNvbHVtbj17IGNvbHVtbiB9IC8+O1xuICB9XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBoZWFkZXJGb3JtYXR0ZXIgP1xuICAgIGhlYWRlckZvcm1hdHRlcihjb2x1bW4sIGluZGV4LCB7IHNvcnRFbGVtZW50OiBzb3J0U3ltYm9sLCBmaWx0ZXJFbGVtZW50OiBmaWx0ZXJFbG0gfSkgOlxuICAgIHRleHQ7XG5cbiAgaWYgKGhlYWRlckZvcm1hdHRlcikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCd0aCcsIGNlbGxBdHRycywgY2hpbGRyZW4pO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3RoJywgY2VsbEF0dHJzLCBjaGlsZHJlbiwgc29ydFN5bWJvbCwgZmlsdGVyRWxtKTtcbn07XG5cbkhlYWRlckNlbGwucHJvcFR5cGVzID0ge1xuICBjb2x1bW46IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZGF0YUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdGV4dDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGhpZGRlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgaGVhZGVyRm9ybWF0dGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBmb3JtYXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGZvcm1hdEV4dHJhRGF0YTogUHJvcFR5cGVzLmFueSxcbiAgICBoZWFkZXJDbGFzc2VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGNsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgaGVhZGVyU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgaGVhZGVyVGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIHRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoZWFkZXJFdmVudHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGhlYWRlckFsaWduOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGFsaWduOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGhlYWRlckF0dHJzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGF0dHJzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIHNvcnQ6IFByb3BUeXBlcy5ib29sLFxuICAgIHNvcnRGdW5jOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGVkaXRvcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBlZGl0YWJsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZWRpdENlbGxTdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBlZGl0Q2VsbENsYXNzZXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZWRpdG9yU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgZWRpdG9yQ2xhc3NlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBlZGl0b3JSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgdmFsaWRhdG9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBmaWx0ZXI6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZmlsdGVyUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGZpbHRlclZhbHVlOiBQcm9wVHlwZXMuZnVuY1xuICB9KS5pc1JlcXVpcmVkLFxuICBpbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvblNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBzb3J0aW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgc29ydE9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfQVNDLCBDb25zdC5TT1JUX0RFU0NdKSxcbiAgaXNMYXN0U29ydGluZzogUHJvcFR5cGVzLmJvb2wsXG4gIG9uRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FeHRlcm5hbEZpbHRlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlckNlbGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9oZWFkZXItY2VsbC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCb290c3RyYXBDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dHMvYm9vdHN0cmFwJztcblxuY29uc3QgU29ydFN5bWJvbCA9ICgpID0+IChcbiAgPEJvb3RzdHJhcENvbnRleHQuQ29uc3VtZXI+XG4gICAge1xuICAgICAgKHsgYm9vdHN0cmFwNCB9KSA9PiAoYm9vdHN0cmFwNCA/IChcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwib3JkZXItNFwiIC8+XG4gICAgICApIDogKFxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJvcmRlclwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImRyb3Bkb3duXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiIC8+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImRyb3B1cFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY2FyZXRcIiAvPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgKSlcbiAgICB9XG4gIDwvQm9vdHN0cmFwQ29udGV4dC5Db25zdW1lcj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFNvcnRTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L3N5bWJvbC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3MgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IHsgQm9vdHN0cmFwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHRzL2Jvb3RzdHJhcCc7XG5cblxuY29uc3QgU29ydENhcmV0ID0gKHsgb3JkZXIgfSkgPT4ge1xuICBjb25zdCBvcmRlckNsYXNzID0gY3MoJ3JlYWN0LWJvb3RzdHJhcC10YWJsZS1zb3J0LW9yZGVyJywge1xuICAgIGRyb3B1cDogb3JkZXIgPT09IENvbnN0LlNPUlRfQVNDXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPEJvb3RzdHJhcENvbnRleHQuQ29uc3VtZXI+XG4gICAgICB7XG4gICAgICAgICh7IGJvb3RzdHJhcDQgfSkgPT4gKGJvb3RzdHJhcDQgPyAoXG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXsgYGNhcmV0LTQtJHtvcmRlcn1gIH0gLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9eyBvcmRlckNsYXNzIH0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiIC8+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICApKVxuICAgICAgfVxuICAgIDwvQm9vdHN0cmFwQ29udGV4dC5Db25zdW1lcj5cbiAgKTtcbn07XG5cblNvcnRDYXJldC5wcm9wVHlwZXMgPSB7XG4gIG9yZGVyOiBQcm9wVHlwZXMub25lT2YoW0NvbnN0LlNPUlRfQVNDLCBDb25zdC5TT1JUX0RFU0NdKS5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0Q2FyZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zb3J0L2NhcmV0LmpzIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS40LjRcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gRXN0YWJsaXNoIHRoZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIHRvIGJyZWFrIG91dCBvZiBhIGxvb3AgaXRlcmF0aW9uLlxuICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIGNvbmNhdCAgICAgICAgICAgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUZvckVhY2ggICAgICA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVNYXAgICAgICAgICAgPSBBcnJheVByb3RvLm1hcCxcbiAgICBuYXRpdmVSZWR1Y2UgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZSxcbiAgICBuYXRpdmVSZWR1Y2VSaWdodCAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0LFxuICAgIG5hdGl2ZUZpbHRlciAgICAgICA9IEFycmF5UHJvdG8uZmlsdGVyLFxuICAgIG5hdGl2ZUV2ZXJ5ICAgICAgICA9IEFycmF5UHJvdG8uZXZlcnksXG4gICAgbmF0aXZlU29tZSAgICAgICAgID0gQXJyYXlQcm90by5zb21lLFxuICAgIG5hdGl2ZUluZGV4T2YgICAgICA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICBuYXRpdmVMYXN0SW5kZXhPZiAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLFxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS40LjQnO1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZm9yRWFjaGAgaWYgYXZhaWxhYmxlLlxuICB2YXIgZWFjaCA9IF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0b3IgdG8gZWFjaCBlbGVtZW50LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIHZhciByZWR1Y2VFcnJvciA9ICdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJztcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VgIGlmIGF2YWlsYWJsZS5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2UoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IHZhbHVlO1xuICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlUmlnaHQgJiYgb2JqLnJlZHVjZVJpZ2h0ID09PSBuYXRpdmVSZWR1Y2VSaWdodCkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09ICtsZW5ndGgpIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaW5kZXggPSBrZXlzID8ga2V5c1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gb2JqW2luZGV4XTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaW5kZXhdLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgYW55KG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmaWx0ZXJgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZUZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHJldHVybiBvYmouZmlsdGVyKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuICFpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgfSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBldmVyeWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KSByZXR1cm4gb2JqLmV2ZXJ5KGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICB2YXIgYW55ID0gXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlU29tZSAmJiBvYmouc29tZSA9PT0gbmF0aXZlU29tZSkgcmV0dXJuIG9iai5zb21lKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocmVzdWx0IHx8IChyZXN1bHQgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMsIGZpcnN0KSB7XG4gICAgaWYgKF8uaXNFbXB0eShhdHRycykpIHJldHVybiBmaXJzdCA/IG51bGwgOiBbXTtcbiAgICByZXR1cm4gX1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IHZhbHVlW2tleV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8ud2hlcmUob2JqLCBhdHRycywgdHJ1ZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgb3IgKGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICAvLyBDYW4ndCBvcHRpbWl6ZSBhcnJheXMgb2YgaW50ZWdlcnMgbG9uZ2VyIHRoYW4gNjUsNTM1IGVsZW1lbnRzLlxuICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD04MDc5N1xuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSAmJiBvYmoubGVuZ3RoIDwgNjU1MzUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBvYmopO1xuICAgIH1cbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gLUluZmluaXR5O1xuICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiAtSW5maW5pdHksIHZhbHVlOiAtSW5maW5pdHl9O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBjb21wdXRlZCA+PSByZXN1bHQuY29tcHV0ZWQgJiYgKHJlc3VsdCA9IHt2YWx1ZSA6IHZhbHVlLCBjb21wdXRlZCA6IGNvbXB1dGVkfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiBJbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogSW5maW5pdHksIHZhbHVlOiBJbmZpbml0eX07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGNvbXB1dGVkIDwgcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhbiBhcnJheS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJhbmQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBbXTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbShpbmRleCsrKTtcbiAgICAgIHNodWZmbGVkW2luZGV4IC0gMV0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGxvb2t1cCBpdGVyYXRvcnMuXG4gIHZhciBsb29rdXBJdGVyYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG9iail7IHJldHVybiBvYmpbdmFsdWVdOyB9O1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRvci5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IodmFsdWUpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICBpbmRleCA6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYSA6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IDwgcmlnaHQuaW5kZXggPyAtMSA6IDE7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCwgYmVoYXZpb3IpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IodmFsdWUgfHwgXy5pZGVudGl0eSk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgYmVoYXZpb3IocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZ3JvdXAob2JqLCB2YWx1ZSwgY29udGV4dCwgZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgICAoXy5oYXMocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiAocmVzdWx0W2tleV0gPSBbXSkpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGdyb3VwKG9iaiwgdmFsdWUsIGNvbnRleHQsIGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgICBpZiAoIV8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0gPSAwO1xuICAgICAgcmVzdWx0W2tleV0rKztcbiAgICB9KTtcbiAgfTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvciA9PSBudWxsID8gXy5pZGVudGl0eSA6IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W21pZF0pIDwgdmFsdWUgPyBsb3cgPSBtaWQgKyAxIDogaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBTYWZlbHkgY29udmVydCBhbnl0aGluZyBpdGVyYWJsZSBpbnRvIGEgcmVhbCwgbGl2ZSBhcnJheS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gKG4gIT0gbnVsbCkgJiYgIWd1YXJkID8gc2xpY2UuY2FsbChhcnJheSwgMCwgbikgOiBhcnJheVswXTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gIC8vIGBfLm1hcGAuXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmICgobiAhPSBudWxsKSAmJiAhZ3VhcmQpIHtcbiAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBNYXRoLm1heChhcnJheS5sZW5ndGggLSBuLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKipcbiAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBvdXRwdXQpIHtcbiAgICBlYWNoKGlucHV0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgc2hhbGxvdyA/IHB1c2guYXBwbHkob3V0cHV0LCB2YWx1ZSkgOiBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBvdXRwdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgW10pO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdG9yO1xuICAgICAgaXRlcmF0b3IgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpbml0aWFsID0gaXRlcmF0b3IgPyBfLm1hcChhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIDogYXJyYXk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGVhY2goaW5pdGlhbCwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoaXNTb3J0ZWQgPyAoIWluZGV4IHx8IHNlZW5bc2Vlbi5sZW5ndGggLSAxXSAhPT0gdmFsdWUpIDogIV8uY29udGFpbnMoc2VlbiwgdmFsdWUpKSB7XG4gICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJlc3VsdHMucHVzaChhcnJheVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIGFyZ3VtZW50cykpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihfLnVuaXEoYXJyYXkpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICByZXR1cm4gXy5pbmRleE9mKG90aGVyLCBpdGVtKSA+PSAwO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7IH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGxlbmd0aCA9IF8ubWF4KF8ucGx1Y2soYXJncywgJ2xlbmd0aCcpKTtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHNbaV0gPSBfLnBsdWNrKGFyZ3MsIFwiXCIgKyBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXG4gIC8vIHdlIG5lZWQgdGhpcyBmdW5jdGlvbi4gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhblxuICAvLyBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XG4gICAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbCArIGlzU29ydGVkKSA6IGlzU29ydGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgZm9yICg7IGkgPCBsOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBsYXN0SW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb20pIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBoYXNJbmRleCA9IGZyb20gIT0gbnVsbDtcbiAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSB7XG4gICAgICByZXR1cm4gaGFzSW5kZXggPyBhcnJheS5sYXN0SW5kZXhPZihpdGVtLCBmcm9tKSA6IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0pO1xuICAgIH1cbiAgICB2YXIgaSA9IChoYXNJbmRleCA/IGZyb20gOiBhcnJheS5sZW5ndGgpO1xuICAgIHdoaWxlIChpLS0pIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcblxuICAgIHZhciBsZW4gPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICB3aGlsZShpZHggPCBsZW4pIHtcbiAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAoZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kICYmIG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCaW5kIGFsbCBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXRcbiAgLy8gYWxsIGNhbGxiYWNrcyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSBmdW5jcyA9IF8uZnVuY3Rpb25zKG9iaik7XG4gICAgZWFjaChmdW5jcywgZnVuY3Rpb24oZikgeyBvYmpbZl0gPSBfLmJpbmQob2JqW2ZdLCBvYmopOyB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0ge307XG4gICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gXy5oYXMobWVtbywga2V5KSA/IG1lbW9ba2V5XSA6IChtZW1vW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7IH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCB0aW1lb3V0LCByZXN1bHQ7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gbmV3IERhdGU7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGU7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH07XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyYW4pIHJldHVybiBtZW1vO1xuICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW2Z1bmNdO1xuICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJncyA9IFtmdW5jc1tpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBhZnRlciBiZWluZyBjYWxsZWQgTiB0aW1lcy5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgaWYgKHRpbWVzIDw9IDApIHJldHVybiBmdW5jKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBuYXRpdmVLZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogIT09IE9iamVjdChvYmopKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9iamVjdCcpO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSB2YWx1ZXMucHVzaChvYmpba2V5XSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBwYWlycyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHBhaXJzLnB1c2goW2tleSwgb2JqW2tleV1dKTtcbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXN1bHRbb2JqW2tleV1dID0ga2V5O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGVhY2goa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoa2V5IGluIG9iaikgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKCFfLmNvbnRhaW5zKGtleXMsIGtleSkpIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChvYmpbcHJvcF0gPT0gbnVsbCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBIYXJtb255IGBlZ2FsYCBwcm9wb3NhbDogaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvclxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgcmV0dXJuIGEuc291cmNlID09IGIuc291cmNlICYmXG4gICAgICAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJlxuICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PSBiO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgdmFyIHNpemUgPSAwLCByZXN1bHQgPSB0cnVlO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGIubGVuZ3RoO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiAoYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKF8uaGFzKGEsIGtleSkpIHtcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlci5cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGZvciAoa2V5IGluIGIpIHtcbiAgICAgICAgICBpZiAoXy5oYXMoYiwga2V5KSAmJiAhKHNpemUtLSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9ICFzaXplO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYiwgW10sIFtdKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxuICBlYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogJiYgXy5oYXMob2JqLCAnY2FsbGVlJykpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuXG4gIGlmICh0eXBlb2YgKC8uLykgIT09ICdmdW5jdGlvbicpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdG9ycy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgIGVzY2FwZToge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICAgJy8nOiAnJiN4MkY7J1xuICAgIH1cbiAgfTtcbiAgZW50aXR5TWFwLnVuZXNjYXBlID0gXy5pbnZlcnQoZW50aXR5TWFwLmVzY2FwZSk7XG5cbiAgLy8gUmVnZXhlcyBjb250YWluaW5nIHRoZSBrZXlzIGFuZCB2YWx1ZXMgbGlzdGVkIGltbWVkaWF0ZWx5IGFib3ZlLlxuICB2YXIgZW50aXR5UmVnZXhlcyA9IHtcbiAgICBlc2NhcGU6ICAgbmV3IFJlZ0V4cCgnWycgKyBfLmtleXMoZW50aXR5TWFwLmVzY2FwZSkuam9pbignJykgKyAnXScsICdnJyksXG4gICAgdW5lc2NhcGU6IG5ldyBSZWdFeHAoJygnICsgXy5rZXlzKGVudGl0eU1hcC51bmVzY2FwZSkuam9pbignfCcpICsgJyknLCAnZycpXG4gIH07XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICBfLmVhY2goWydlc2NhcGUnLCAndW5lc2NhcGUnXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgX1ttZXRob2RdID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBpZiAoc3RyaW5nID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHJldHVybiAoJycgKyBzdHJpbmcpLnJlcGxhY2UoZW50aXR5UmVnZXhlc1ttZXRob2RdLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW50aXR5TWFwW21ldGhvZF1bbWF0Y2hdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0O1xuICAvLyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHQnOiAgICAgJ3QnLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHR8XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gICAgdmFyIHJlbmRlcjtcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgICAucmVwbGFjZShlc2NhcGVyLCBmdW5jdGlvbihtYXRjaCkgeyByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07IH0pO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgXCJyZXR1cm4gX19wO1xcblwiO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIChzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJykgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbiwgd2hpY2ggd2lsbCBkZWxlZ2F0ZSB0byB0aGUgd3JhcHBlci5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfKG9iaikuY2hhaW4oKTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT0gJ3NoaWZ0JyB8fCBuYW1lID09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgXy5leHRlbmQoXy5wcm90b3R5cGUsIHtcblxuICAgIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgICBjaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jaGFpbiA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gICAgfVxuXG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcbmltcG9ydCB7IEJvb3RzdHJhcENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0cy9ib290c3RyYXAnO1xuXG5leHBvcnQgY29uc3QgQ2hlY2tCb3ggPSAoeyBjbGFzc05hbWUsIGNoZWNrZWQsIGluZGV0ZXJtaW5hdGUgfSkgPT4gKFxuICA8aW5wdXRcbiAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgIGNoZWNrZWQ9eyBjaGVja2VkIH1cbiAgICBjbGFzc05hbWU9eyBjbGFzc05hbWUgfVxuICAgIHJlZj17IChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0KSBpbnB1dC5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIH0gfVxuICAvPlxuKTtcblxuQ2hlY2tCb3gucHJvcFR5cGVzID0ge1xuICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdGlvbkhlYWRlckNlbGwgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG1vZGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBjaGVja2VkU3RhdHVzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQWxsUm93c1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2VsZWN0aW9uSGVhZGVyUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaGFuZGxlQ2hlY2tCb3hDbGljayA9IHRoaXMuaGFuZGxlQ2hlY2tCb3hDbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGF2b2lkIHVwZGF0aW5nIGlmIGJ1dHRvbiBpc1xuICAgKiAxLiByYWRpb1xuICAgKiAyLiBzdGF0dXMgd2FzIG5vdCBjaGFuZ2VkLlxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHsgUk9XX1NFTEVDVF9TSU5HTEUgfSA9IENvbnN0O1xuICAgIGNvbnN0IHsgbW9kZSwgY2hlY2tlZFN0YXR1cyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChtb2RlID09PSBST1dfU0VMRUNUX1NJTkdMRSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIG5leHRQcm9wcy5jaGVja2VkU3RhdHVzICE9PSBjaGVja2VkU3RhdHVzO1xuICB9XG5cbiAgaGFuZGxlQ2hlY2tCb3hDbGljayhlKSB7XG4gICAgY29uc3QgeyBvbkFsbFJvd3NTZWxlY3QsIGNoZWNrZWRTdGF0dXMgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgaXNVblNlbGVjdCA9XG4gICAgICBjaGVja2VkU3RhdHVzID09PSBDb25zdC5DSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRCB8fFxuICAgICAgY2hlY2tlZFN0YXR1cyA9PT0gQ29uc3QuQ0hFQ0tCT1hfU1RBVFVTX0lOREVURVJNSU5BVEU7XG5cbiAgICBvbkFsbFJvd3NTZWxlY3QoZSwgaXNVblNlbGVjdCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgQ0hFQ0tCT1hfU1RBVFVTX0NIRUNLRUQsIENIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFLCBST1dfU0VMRUNUX01VTFRJUExFXG4gICAgfSA9IENvbnN0O1xuXG4gICAgY29uc3QgeyBtb2RlLCBjaGVja2VkU3RhdHVzLCBzZWxlY3Rpb25IZWFkZXJSZW5kZXJlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNoZWNrZWQgPSBjaGVja2VkU3RhdHVzID09PSBDSEVDS0JPWF9TVEFUVVNfQ0hFQ0tFRDtcblxuICAgIGNvbnN0IGluZGV0ZXJtaW5hdGUgPSBjaGVja2VkU3RhdHVzID09PSBDSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURTtcblxuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgaWYgKHNlbGVjdGlvbkhlYWRlclJlbmRlcmVyIHx8IG1vZGUgPT09IFJPV19TRUxFQ1RfTVVMVElQTEUpIHtcbiAgICAgIGF0dHJzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUNoZWNrQm94Q2xpY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb290c3RyYXBDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICB7XG4gICAgICAgICAgKHsgYm9vdHN0cmFwNCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uSGVhZGVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IHNlbGVjdGlvbkhlYWRlclJlbmRlcmVyKHtcbiAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gUk9XX1NFTEVDVF9NVUxUSVBMRSkge1xuICAgICAgICAgICAgICBjb250ZW50ID0gKFxuICAgICAgICAgICAgICAgIDxDaGVja0JveFxuICAgICAgICAgICAgICAgICAgeyAuLi50aGlzLnByb3BzIH1cbiAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9eyBjaGVja2VkIH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17IGJvb3RzdHJhcDQgPyAnc2VsZWN0aW9uLWlucHV0LTQnIDogJycgfVxuICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZT17IGluZGV0ZXJtaW5hdGUgfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8dGggZGF0YS1yb3ctc2VsZWN0aW9uIHsgLi4uYXR0cnMgfT57IGNvbnRlbnQgfTwvdGg+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgPC9Cb290c3RyYXBDb250ZXh0LkNvbnN1bWVyPlxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1zZWxlY3Rpb24vc2VsZWN0aW9uLWhlYWRlci1jZWxsLmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0aW9uSGVhZGVyQ2VsbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYW55RXhwYW5kczogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBvbkFsbFJvd0V4cGFuZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICByZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmNcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oYW5kbGVDaGVja0JveENsaWNrID0gdGhpcy5oYW5kbGVDaGVja0JveENsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBoYW5kbGVDaGVja0JveENsaWNrKGUpIHtcbiAgICBjb25zdCB7IGFueUV4cGFuZHMsIG9uQWxsUm93RXhwYW5kIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgb25BbGxSb3dFeHBhbmQoZSwgIWFueUV4cGFuZHMpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYW55RXhwYW5kcywgcmVuZGVyZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNoZWNrQm94Q2xpY2tcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0aCBkYXRhLXJvdy1zZWxlY3Rpb24geyAuLi5hdHRycyB9PlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyZXIgP1xuICAgICAgICAgICAgcmVuZGVyZXIoeyBpc0FueUV4cGFuZHM6IGFueUV4cGFuZHMgfSkgOlxuICAgICAgICAgICAgKGFueUV4cGFuZHMgPyAnKC0pJyA6ICcoKyknKVxuICAgICAgICB9XG4gICAgICA8L3RoPlxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1leHBhbmQvZXhwYW5kLWhlYWRlci1jZWxsLmpzIiwiLyogZXNsaW50IHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IENhcHRpb24gPSAocHJvcHMpID0+IHtcbiAgaWYgKCFwcm9wcy5jaGlsZHJlbikgcmV0dXJuIG51bGw7XG4gIHJldHVybiAoXG4gICAgPGNhcHRpb24+eyBwcm9wcy5jaGlsZHJlbiB9PC9jYXB0aW9uPlxuICApO1xufTtcblxuQ2FwdGlvbi5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubm9kZSxcbiAgICBQcm9wVHlwZXMuc3RyaW5nXG4gIF0pXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYXB0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY2FwdGlvbi5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG4vKiBlc2xpbnQgcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzOiAwICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgXyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBSb3cgZnJvbSAnLi9yb3cnO1xuaW1wb3J0IEV4cGFuZFJvdyBmcm9tICcuL3Jvdy1leHBhbmQvZXhwYW5kLXJvdyc7XG5pbXBvcnQgUm93U2VjdGlvbiBmcm9tICcuL3Jvdy1zZWN0aW9uJztcbmltcG9ydCBDb25zdCBmcm9tICcuL2NvbnN0JztcblxuY29uc3QgQm9keSA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgY29sdW1ucyxcbiAgICBkYXRhLFxuICAgIGtleUZpZWxkLFxuICAgIGlzRW1wdHksXG4gICAgbm9EYXRhSW5kaWNhdGlvbixcbiAgICB2aXNpYmxlQ29sdW1uU2l6ZSxcbiAgICBjZWxsRWRpdCxcbiAgICBzZWxlY3RSb3csXG4gICAgc2VsZWN0ZWRSb3dLZXlzLFxuICAgIHJvd1N0eWxlLFxuICAgIHJvd0NsYXNzZXMsXG4gICAgcm93RXZlbnRzLFxuICAgIGV4cGFuZFJvd1xuICB9ID0gcHJvcHM7XG5cbiAgY29uc3Qge1xuICAgIGJnQ29sb3IsXG4gICAgbm9uU2VsZWN0YWJsZVxuICB9ID0gc2VsZWN0Um93O1xuXG4gIGxldCBjb250ZW50O1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgY29uc3QgaW5kaWNhdGlvbiA9IF8uaXNGdW5jdGlvbihub0RhdGFJbmRpY2F0aW9uKSA/IG5vRGF0YUluZGljYXRpb24oKSA6IG5vRGF0YUluZGljYXRpb247XG4gICAgaWYgKCFpbmRpY2F0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29udGVudCA9IDxSb3dTZWN0aW9uIGNvbnRlbnQ9eyBpbmRpY2F0aW9uIH0gY29sU3Bhbj17IHZpc2libGVDb2x1bW5TaXplIH0gLz47XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9uRWRpdGFibGVSb3dzID0gY2VsbEVkaXQubm9uRWRpdGFibGVSb3dzIHx8IFtdO1xuICAgIGNvbnRlbnQgPSBkYXRhLm1hcCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gXy5nZXQocm93LCBrZXlGaWVsZCk7XG4gICAgICBjb25zdCBlZGl0YWJsZSA9ICEobm9uRWRpdGFibGVSb3dzLmxlbmd0aCA+IDAgJiYgbm9uRWRpdGFibGVSb3dzLmluZGV4T2Yoa2V5KSA+IC0xKTtcblxuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RSb3cubW9kZSAhPT0gQ29uc3QuUk9XX1NFTEVDVF9ESVNBQkxFRFxuICAgICAgICA/IHNlbGVjdGVkUm93S2V5cy5pbmNsdWRlcyhrZXkpXG4gICAgICAgIDogbnVsbDtcblxuICAgICAgY29uc3QgYXR0cnMgPSByb3dFdmVudHMgfHwge307XG4gICAgICBsZXQgc3R5bGUgPSBfLmlzRnVuY3Rpb24ocm93U3R5bGUpID8gcm93U3R5bGUocm93LCBpbmRleCkgOiByb3dTdHlsZTtcbiAgICAgIGxldCBjbGFzc2VzID0gKF8uaXNGdW5jdGlvbihyb3dDbGFzc2VzKSA/IHJvd0NsYXNzZXMocm93LCBpbmRleCkgOiByb3dDbGFzc2VzKTtcbiAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZFN0eWxlID0gXy5pc0Z1bmN0aW9uKHNlbGVjdFJvdy5zdHlsZSlcbiAgICAgICAgICA/IHNlbGVjdFJvdy5zdHlsZShyb3csIGluZGV4KVxuICAgICAgICAgIDogc2VsZWN0Um93LnN0eWxlO1xuXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ2xhc3NlcyA9IF8uaXNGdW5jdGlvbihzZWxlY3RSb3cuY2xhc3NlcylcbiAgICAgICAgICA/IHNlbGVjdFJvdy5jbGFzc2VzKHJvdywgaW5kZXgpXG4gICAgICAgICAgOiBzZWxlY3RSb3cuY2xhc3NlcztcblxuICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAuLi5zZWxlY3RlZFN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzZXMgPSBjcyhjbGFzc2VzLCBzZWxlY3RlZENsYXNzZXMpO1xuXG4gICAgICAgIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBfLmlzRnVuY3Rpb24oYmdDb2xvcikgPyBiZ0NvbG9yKHJvdywgaW5kZXgpIDogYmdDb2xvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxlY3RhYmxlID0gIW5vblNlbGVjdGFibGUgfHwgIW5vblNlbGVjdGFibGUuaW5jbHVkZXMoa2V5KTtcbiAgICAgIGNvbnN0IGV4cGFuZGFibGUgPSBleHBhbmRSb3cgJiYgIWV4cGFuZFJvdy5ub25FeHBhbmRhYmxlLmluY2x1ZGVzKGtleSk7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZFJvdyAmJiBleHBhbmRSb3cuZXhwYW5kZWQuaW5jbHVkZXMoa2V5KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgICA8Um93XG4gICAgICAgICAga2V5PXsga2V5IH1cbiAgICAgICAgICByb3c9eyByb3cgfVxuICAgICAgICAgIGtleUZpZWxkPXsga2V5RmllbGQgfVxuICAgICAgICAgIHJvd0luZGV4PXsgaW5kZXggfVxuICAgICAgICAgIGNvbHVtbnM9eyBjb2x1bW5zIH1cbiAgICAgICAgICBjZWxsRWRpdD17IGNlbGxFZGl0IH1cbiAgICAgICAgICBlZGl0YWJsZT17IGVkaXRhYmxlIH1cbiAgICAgICAgICBzZWxlY3RhYmxlPXsgc2VsZWN0YWJsZSB9XG4gICAgICAgICAgZXhwYW5kYWJsZT17IGV4cGFuZGFibGUgfVxuICAgICAgICAgIHNlbGVjdGVkPXsgc2VsZWN0ZWQgfVxuICAgICAgICAgIGV4cGFuZGVkPXsgZXhwYW5kZWQgfVxuICAgICAgICAgIHNlbGVjdFJvdz17IHNlbGVjdFJvdyB9XG4gICAgICAgICAgZXhwYW5kUm93PXsgZXhwYW5kUm93IH1cbiAgICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgICAgICBjbGFzc05hbWU9eyBjbGFzc2VzIH1cbiAgICAgICAgICBhdHRycz17IGF0dHJzIH1cbiAgICAgICAgLz5cbiAgICAgIF07XG5cbiAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICByZXN1bHQucHVzaCgoXG4gICAgICAgICAgPEV4cGFuZFJvd1xuICAgICAgICAgICAga2V5PXsgYCR7a2V5fS1leHBhbmRpbmdgIH1cbiAgICAgICAgICAgIGNvbFNwYW49eyB2aXNpYmxlQ29sdW1uU2l6ZSB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgeyBleHBhbmRSb3cucmVuZGVyZXIocm93KSB9XG4gICAgICAgICAgPC9FeHBhbmRSb3c+XG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8dGJvZHk+eyBjb250ZW50IH08L3Rib2R5PlxuICApO1xufTtcblxuQm9keS5wcm9wVHlwZXMgPSB7XG4gIGtleUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgc2VsZWN0Um93OiBQcm9wVHlwZXMub2JqZWN0LFxuICBzZWxlY3RlZFJvd0tleXM6IFByb3BUeXBlcy5hcnJheVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQm9keTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2JvZHkuanMiLCIvKiBlc2xpbnQgcmVhY3QvcHJvcC10eXBlczogMCAqL1xuLyogZXNsaW50IHJlYWN0L25vLWFycmF5LWluZGV4LWtleTogMCAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9jZWxsJztcbmltcG9ydCBTZWxlY3Rpb25DZWxsIGZyb20gJy4vcm93LXNlbGVjdGlvbi9zZWxlY3Rpb24tY2VsbCc7XG5pbXBvcnQgRXhwYW5kQ2VsbCBmcm9tICcuL3Jvdy1leHBhbmQvZXhwYW5kLWNlbGwnO1xuaW1wb3J0IGV2ZW50RGVsZWdhdGVyIGZyb20gJy4vcm93LWV2ZW50LWRlbGVnYXRlcic7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdCc7XG5cbmNsYXNzIFJvdyBleHRlbmRzIGV2ZW50RGVsZWdhdGVyKENvbXBvbmVudCkge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm93LFxuICAgICAgY29sdW1ucyxcbiAgICAgIGtleUZpZWxkLFxuICAgICAgcm93SW5kZXgsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGF0dHJzLFxuICAgICAgY2VsbEVkaXQsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHNlbGVjdFJvdyxcbiAgICAgIGV4cGFuZGVkLFxuICAgICAgZXhwYW5kUm93LFxuICAgICAgc2VsZWN0YWJsZSxcbiAgICAgIGVkaXRhYmxlOiBlZGl0YWJsZVJvd1xuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qge1xuICAgICAgbW9kZSxcbiAgICAgIG9uU3RhcnQsXG4gICAgICBFZGl0aW5nQ2VsbCxcbiAgICAgIHJpZHg6IGVkaXRpbmdSb3dJZHgsXG4gICAgICBjaWR4OiBlZGl0aW5nQ29sSWR4LFxuICAgICAgQ0xJQ0tfVE9fQ0VMTF9FRElULFxuICAgICAgREJDTElDS19UT19DRUxMX0VESVQsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IGNlbGxFZGl0O1xuXG4gICAgY29uc3Qga2V5ID0gXy5nZXQocm93LCBrZXlGaWVsZCk7XG4gICAgY29uc3QgeyBoaWRlU2VsZWN0Q29sdW1uIH0gPSBzZWxlY3RSb3c7XG4gICAgY29uc3QgeyBzaG93RXhwYW5kQ29sdW1uIH0gPSBleHBhbmRSb3cgfHwge307XG4gICAgY29uc3QgdHJBdHRycyA9IHRoaXMuZGVsZWdhdGUoYXR0cnMpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ciBzdHlsZT17IHN0eWxlIH0gY2xhc3NOYW1lPXsgY2xhc3NOYW1lIH0geyAuLi50ckF0dHJzIH0+XG4gICAgICAgIHtcbiAgICAgICAgICBzaG93RXhwYW5kQ29sdW1uID8gKFxuICAgICAgICAgICAgPEV4cGFuZENlbGxcbiAgICAgICAgICAgICAgeyAuLi5leHBhbmRSb3cgfVxuICAgICAgICAgICAgICByb3dLZXk9eyBrZXkgfVxuICAgICAgICAgICAgICByb3dJbmRleD17IHJvd0luZGV4IH1cbiAgICAgICAgICAgICAgZXhwYW5kZWQ9eyBleHBhbmRlZCB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkgOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIChzZWxlY3RSb3cubW9kZSAhPT0gQ29uc3QuUk9XX1NFTEVDVF9ESVNBQkxFRCAmJiAhaGlkZVNlbGVjdENvbHVtbilcbiAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICA8U2VsZWN0aW9uQ2VsbFxuICAgICAgICAgICAgICAgIHsgLi4uc2VsZWN0Um93IH1cbiAgICAgICAgICAgICAgICByb3dLZXk9eyBrZXkgfVxuICAgICAgICAgICAgICAgIHJvd0luZGV4PXsgcm93SW5kZXggfVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkPXsgc2VsZWN0ZWQgfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXsgIXNlbGVjdGFibGUgfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbHVtbnMubWFwKChjb2x1bW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbHVtbi5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhRmllbGQgfSA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IF8uZ2V0KHJvdywgZGF0YUZpZWxkKTtcbiAgICAgICAgICAgICAgbGV0IGVkaXRhYmxlID0gXy5pc0RlZmluZWQoY29sdW1uLmVkaXRhYmxlKSA/IGNvbHVtbi5lZGl0YWJsZSA6IHRydWU7XG4gICAgICAgICAgICAgIGlmIChkYXRhRmllbGQgPT09IGtleUZpZWxkIHx8ICFlZGl0YWJsZVJvdykgZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgZWRpdGFibGUgPSBjb2x1bW4uZWRpdGFibGUoY29udGVudCwgcm93LCByb3dJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyb3dJbmRleCA9PT0gZWRpdGluZ1Jvd0lkeCAmJiBpbmRleCA9PT0gZWRpdGluZ0NvbElkeCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGl0Q2VsbHN0eWxlID0gY29sdW1uLmVkaXRDZWxsU3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgbGV0IGVkaXRDZWxsY2xhc3NlcyA9IGNvbHVtbi5lZGl0Q2VsbENsYXNzZXM7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdENlbGxTdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgIGVkaXRDZWxsc3R5bGUgPSBjb2x1bW4uZWRpdENlbGxTdHlsZShjb250ZW50LCByb3csIHJvd0luZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29sdW1uLmVkaXRDZWxsQ2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICAgIGVkaXRDZWxsY2xhc3NlcyA9IGNvbHVtbi5lZGl0Q2VsbENsYXNzZXMoY29udGVudCwgcm93LCByb3dJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPEVkaXRpbmdDZWxsXG4gICAgICAgICAgICAgICAgICAgIGtleT17IGAke2NvbnRlbnR9LSR7aW5kZXh9YCB9XG4gICAgICAgICAgICAgICAgICAgIHJvdz17IHJvdyB9XG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4PXsgcm93SW5kZXggfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW49eyBjb2x1bW4gfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleD17IGluZGV4IH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXsgZWRpdENlbGxjbGFzc2VzIH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9eyBlZGl0Q2VsbHN0eWxlIH1cbiAgICAgICAgICAgICAgICAgICAgeyAuLi5yZXN0IH1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyByZW5kZXIgY2VsbFxuICAgICAgICAgICAgICBsZXQgY2VsbFRpdGxlO1xuICAgICAgICAgICAgICBsZXQgY2VsbFN0eWxlID0ge307XG4gICAgICAgICAgICAgIGNvbnN0IGNlbGxBdHRycyA9IHtcbiAgICAgICAgICAgICAgICAuLi5fLmlzRnVuY3Rpb24oY29sdW1uLmF0dHJzKVxuICAgICAgICAgICAgICAgICAgPyBjb2x1bW4uYXR0cnMoY29udGVudCwgcm93LCByb3dJbmRleCwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICA6IGNvbHVtbi5hdHRycyxcbiAgICAgICAgICAgICAgICAuLi5jb2x1bW4uZXZlbnRzXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgY29uc3QgY2VsbENsYXNzZXMgPSBfLmlzRnVuY3Rpb24oY29sdW1uLmNsYXNzZXMpXG4gICAgICAgICAgICAgICAgPyBjb2x1bW4uY2xhc3Nlcyhjb250ZW50LCByb3csIHJvd0luZGV4LCBpbmRleClcbiAgICAgICAgICAgICAgICA6IGNvbHVtbi5jbGFzc2VzO1xuXG4gICAgICAgICAgICAgIGlmIChjb2x1bW4uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjZWxsU3R5bGUgPSBfLmlzRnVuY3Rpb24oY29sdW1uLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgPyBjb2x1bW4uc3R5bGUoY29udGVudCwgcm93LCByb3dJbmRleCwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICA6IGNvbHVtbi5zdHlsZTtcbiAgICAgICAgICAgICAgICBjZWxsU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBjZWxsU3R5bGUpIHx8IHt9O1xuICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICBpZiAoY29sdW1uLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgY2VsbFRpdGxlID0gXy5pc0Z1bmN0aW9uKGNvbHVtbi50aXRsZSlcbiAgICAgICAgICAgICAgICAgID8gY29sdW1uLnRpdGxlKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgICAgICAgOiBjb250ZW50O1xuICAgICAgICAgICAgICAgIGNlbGxBdHRycy50aXRsZSA9IGNlbGxUaXRsZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb2x1bW4uYWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjZWxsU3R5bGUudGV4dEFsaWduID1cbiAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihjb2x1bW4uYWxpZ24pXG4gICAgICAgICAgICAgICAgICAgID8gY29sdW1uLmFsaWduKGNvbnRlbnQsIHJvdywgcm93SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICA6IGNvbHVtbi5hbGlnbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjZWxsQ2xhc3NlcykgY2VsbEF0dHJzLmNsYXNzTmFtZSA9IGNlbGxDbGFzc2VzO1xuICAgICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdChjZWxsU3R5bGUpKSBjZWxsQXR0cnMuc3R5bGUgPSBjZWxsU3R5bGU7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8Q2VsbFxuICAgICAgICAgICAgICAgICAga2V5PXsgYCR7Y29udGVudH0tJHtpbmRleH1gIH1cbiAgICAgICAgICAgICAgICAgIHJvdz17IHJvdyB9XG4gICAgICAgICAgICAgICAgICByb3dJbmRleD17IHJvd0luZGV4IH1cbiAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4PXsgaW5kZXggfVxuICAgICAgICAgICAgICAgICAgY29sdW1uPXsgY29sdW1uIH1cbiAgICAgICAgICAgICAgICAgIG9uU3RhcnQ9eyBvblN0YXJ0IH1cbiAgICAgICAgICAgICAgICAgIGVkaXRhYmxlPXsgZWRpdGFibGUgfVxuICAgICAgICAgICAgICAgICAgY2xpY2tUb0VkaXQ9eyBtb2RlID09PSBDTElDS19UT19DRUxMX0VESVQgfVxuICAgICAgICAgICAgICAgICAgZGJjbGlja1RvRWRpdD17IG1vZGUgPT09IERCQ0xJQ0tfVE9fQ0VMTF9FRElUIH1cbiAgICAgICAgICAgICAgICAgIHsgLi4uY2VsbEF0dHJzIH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIDwvdHI+XG4gICAgKTtcbiAgfVxufVxuXG5Sb3cucHJvcFR5cGVzID0ge1xuICByb3c6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF0dHJzOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5Sb3cuZGVmYXVsdFByb3BzID0ge1xuICBlZGl0YWJsZTogdHJ1ZSxcbiAgc3R5bGU6IHt9LFxuICBjbGFzc05hbWU6IG51bGwsXG4gIGF0dHJzOiB7fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUm93O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgXyBmcm9tICcuL3V0aWxzJztcblxuY2xhc3MgQ2VsbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuaGFuZGxlRWRpdGluZ0NlbGwgPSB0aGlzLmhhbmRsZUVkaXRpbmdDZWxsLmJpbmQodGhpcyk7XG4gIH1cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlID1cbiAgICAgIF8uZ2V0KHRoaXMucHJvcHMucm93LCB0aGlzLnByb3BzLmNvbHVtbi5kYXRhRmllbGQpXG4gICAgICAgICE9PSBfLmdldChuZXh0UHJvcHMucm93LCBuZXh0UHJvcHMuY29sdW1uLmRhdGFGaWVsZCkgfHxcbiAgICAgIHRoaXMucHJvcHMuY29sdW1uLmhpZGRlbiAhPT0gbmV4dFByb3BzLmNvbHVtbi5oaWRkZW4gfHxcbiAgICAgIHRoaXMucHJvcHMucm93SW5kZXggIT09IG5leHRQcm9wcy5yb3dJbmRleCB8fFxuICAgICAgdGhpcy5wcm9wcy5jb2x1bW5JbmRleCAhPT0gbmV4dFByb3BzLmNvbHVtbkluZGV4IHx8XG4gICAgICB0aGlzLnByb3BzLmNsYXNzTmFtZSAhPT0gbmV4dFByb3BzLmNsYXNzTmFtZSB8fFxuICAgICAgdGhpcy5wcm9wcy50aXRsZSAhPT0gbmV4dFByb3BzLnRpdGxlIHx8XG4gICAgICB0aGlzLnByb3BzLmVkaXRhYmxlICE9PSBuZXh0UHJvcHMuZWRpdGFibGUgfHxcbiAgICAgIHRoaXMucHJvcHMuY2xpY2tUb0VkaXQgIT09IG5leHRQcm9wcy5jbGlja1RvRWRpdCB8fFxuICAgICAgdGhpcy5wcm9wcy5kYmNsaWNrVG9FZGl0ICE9PSBuZXh0UHJvcHMuZGJjbGlja1RvRWRpdCB8fFxuICAgICAgIV8uaXNFcXVhbCh0aGlzLnByb3BzLnN0eWxlLCBuZXh0UHJvcHMuc3R5bGUpIHx8XG4gICAgICAhXy5pc0VxdWFsKHRoaXMucHJvcHMuY29sdW1uLmZvcm1hdEV4dHJhRGF0YSwgbmV4dFByb3BzLmNvbHVtbi5mb3JtYXRFeHRyYURhdGEpIHx8XG4gICAgICAhXy5pc0VxdWFsKHRoaXMucHJvcHMuY29sdW1uLmV2ZW50cywgbmV4dFByb3BzLmNvbHVtbi5ldmVudHMpIHx8XG4gICAgICAhXy5pc0VxdWFsKHRoaXMucHJvcHMuY29sdW1uLmF0dHJzLCBuZXh0UHJvcHMuY29sdW1uLmF0dHJzKTtcbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaGFuZGxlRWRpdGluZ0NlbGwoZSkge1xuICAgIGNvbnN0IHsgY29sdW1uLCBvblN0YXJ0LCByb3dJbmRleCwgY29sdW1uSW5kZXgsIGNsaWNrVG9FZGl0LCBkYmNsaWNrVG9FZGl0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZXZlbnRzIH0gPSBjb2x1bW47XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgaWYgKGNsaWNrVG9FZGl0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUNsaWNrID0gZXZlbnRzLm9uQ2xpY2s7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tQ2xpY2spKSBjdXN0b21DbGljayhlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGJjbGlja1RvRWRpdCkge1xuICAgICAgICBjb25zdCBjdXN0b21EYkNsaWNrID0gZXZlbnRzLm9uRG91YmxlQ2xpY2s7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY3VzdG9tRGJDbGljaykpIGN1c3RvbURiQ2xpY2soZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICBvblN0YXJ0KHJvd0luZGV4LCBjb2x1bW5JbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdyxcbiAgICAgIHJvd0luZGV4LFxuICAgICAgY29sdW1uLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICBvblN0YXJ0LFxuICAgICAgZWRpdGFibGUsXG4gICAgICBjbGlja1RvRWRpdCxcbiAgICAgIGRiY2xpY2tUb0VkaXQsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YUZpZWxkLFxuICAgICAgZm9ybWF0dGVyLFxuICAgICAgZm9ybWF0RXh0cmFEYXRhXG4gICAgfSA9IGNvbHVtbjtcbiAgICBjb25zdCBhdHRycyA9IHsgLi4ucmVzdCB9O1xuICAgIGxldCBjb250ZW50ID0gXy5nZXQocm93LCBkYXRhRmllbGQpO1xuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgY29udGVudCA9IGNvbHVtbi5mb3JtYXR0ZXIoY29udGVudCwgcm93LCByb3dJbmRleCwgZm9ybWF0RXh0cmFEYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoY2xpY2tUb0VkaXQgJiYgZWRpdGFibGUpIHtcbiAgICAgIGF0dHJzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUVkaXRpbmdDZWxsO1xuICAgIH0gZWxzZSBpZiAoZGJjbGlja1RvRWRpdCAmJiBlZGl0YWJsZSkge1xuICAgICAgYXR0cnMub25Eb3VibGVDbGljayA9IHRoaXMuaGFuZGxlRWRpdGluZ0NlbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ZCB7IC4uLmF0dHJzIH0+XG4gICAgICAgIHsgdHlwZW9mIGNvbnRlbnQgPT09ICdib29sZWFuJyA/IGAke2NvbnRlbnR9YCA6IGNvbnRlbnQgfVxuICAgICAgPC90ZD5cbiAgICApO1xuICB9XG59XG5cbkNlbGwucHJvcFR5cGVzID0ge1xuICByb3c6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY29sdW1uOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNvbHVtbkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENlbGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jZWxsLmpzIiwiLyogZXNsaW50XG4gIHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMFxuICBqc3gtYTExeS9uby1ub25pbnRlcmFjdGl2ZS1lbGVtZW50LWludGVyYWN0aW9uczogMFxuKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcbmltcG9ydCB7IEJvb3RzdHJhcENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0cy9ib290c3RyYXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3Rpb25DZWxsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBtb2RlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcm93S2V5OiBQcm9wVHlwZXMuYW55LFxuICAgIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvblJvd1NlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIHJvd0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGNsaWNrVG9TZWxlY3Q6IFByb3BUeXBlcy5ib29sLFxuICAgIHNlbGVjdGlvblJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuY1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHsgc2VsZWN0ZWQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gbmV4dFByb3BzLnNlbGVjdGVkICE9PSBzZWxlY3RlZDtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RlOiBpbnB1dFR5cGUsXG4gICAgICByb3dLZXksXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIG9uUm93U2VsZWN0LFxuICAgICAgZGlzYWJsZWQsXG4gICAgICByb3dJbmRleCxcbiAgICAgIGNsaWNrVG9TZWxlY3RcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmIChjbGlja1RvU2VsZWN0KSByZXR1cm47XG5cbiAgICBjb25zdCBjaGVja2VkID0gaW5wdXRUeXBlID09PSBDb25zdC5ST1dfU0VMRUNUX1NJTkdMRVxuICAgICAgPyB0cnVlXG4gICAgICA6ICFzZWxlY3RlZDtcblxuICAgIG9uUm93U2VsZWN0KHJvd0tleSwgY2hlY2tlZCwgcm93SW5kZXgsIGUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGU6IGlucHV0VHlwZSxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBzZWxlY3Rpb25SZW5kZXJlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb290c3RyYXBDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICB7XG4gICAgICAgICAgKHsgYm9vdHN0cmFwNCB9KSA9PiAoXG4gICAgICAgICAgICA8dGQgb25DbGljaz17IHRoaXMuaGFuZGxlQ2xpY2sgfT5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblJlbmRlcmVyID8gc2VsZWN0aW9uUmVuZGVyZXIoe1xuICAgICAgICAgICAgICAgICAgbW9kZTogaW5wdXRUeXBlLFxuICAgICAgICAgICAgICAgICAgY2hlY2tlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIH0pIDogKFxuICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9eyBpbnB1dFR5cGUgfVxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXsgc2VsZWN0ZWQgfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IGRpc2FibGVkIH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXsgYm9vdHN0cmFwNCA/ICdzZWxlY3Rpb24taW5wdXQtNCcgOiAnJyB9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIDwvQm9vdHN0cmFwQ29udGV4dC5Db25zdW1lcj5cbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctc2VsZWN0aW9uL3NlbGVjdGlvbi1jZWxsLmpzIiwiLyogZXNsaW50XG4gIHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wczogMFxuICBqc3gtYTExeS9uby1ub25pbnRlcmFjdGl2ZS1lbGVtZW50LWludGVyYWN0aW9uczogMFxuKi9cbi8qIGVzbGludCBuby1uZXN0ZWQtdGVybmFyeTogMCAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cGFuZENlbGwgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIHJvd0tleTogUHJvcFR5cGVzLmFueSxcbiAgICBleHBhbmRlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBvblJvd0V4cGFuZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBleHBhbmRDb2x1bW5SZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXJcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oYW5kbGVDbGljayA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKGUpIHtcbiAgICBjb25zdCB7IHJvd0tleSwgZXhwYW5kZWQsIG9uUm93RXhwYW5kLCByb3dJbmRleCB9ID0gdGhpcy5wcm9wcztcblxuICAgIG9uUm93RXhwYW5kKHJvd0tleSwgZXhwYW5kZWQsIHJvd0luZGV4LCBlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGV4cGFuZGVkLCBleHBhbmRDb2x1bW5SZW5kZXJlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8dGQgb25DbGljaz17IHRoaXMuaGFuZGxlQ2xpY2sgfT5cbiAgICAgICAge1xuICAgICAgICAgIGV4cGFuZENvbHVtblJlbmRlcmVyID8gZXhwYW5kQ29sdW1uUmVuZGVyZXIoe1xuICAgICAgICAgICAgZXhwYW5kZWRcbiAgICAgICAgICB9KSA6IChleHBhbmRlZCA/ICcoLSknIDogJygrKScpXG4gICAgICAgIH1cbiAgICAgIDwvdGQ+XG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LWV4cGFuZC9leHBhbmQtY2VsbC5qcyIsImltcG9ydCBfIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4vY29uc3QnO1xuXG5jb25zdCBldmVudHMgPSBbXG4gICdvbkNsaWNrJyxcbiAgJ29uRG91YmxlQ2xpY2snLFxuICAnb25Nb3VzZUVudGVyJyxcbiAgJ29uTW91c2VMZWF2ZSdcbl07XG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuZEJhc2UgPT5cbiAgY2xhc3MgUm93RXZlbnREZWxlZ2F0ZXIgZXh0ZW5kcyBFeHRlbmRCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5jbGlja051bSA9IDA7XG4gICAgICB0aGlzLmNyZWF0ZURlZmF1bHRFdmVudEhhbmRsZXIgPSB0aGlzLmNyZWF0ZURlZmF1bHRFdmVudEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY3JlYXRlQ2xpY2tFdmVudEhhbmRsZXIgPSB0aGlzLmNyZWF0ZUNsaWNrRXZlbnRIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlcihjYikge1xuICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcm93LCByb3dJbmRleCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY2IoZSwgcm93LCByb3dJbmRleCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNyZWF0ZUNsaWNrRXZlbnRIYW5kbGVyKGNiKSB7XG4gICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICBrZXlGaWVsZCxcbiAgICAgICAgICBzZWxlY3RhYmxlLFxuICAgICAgICAgIGV4cGFuZGFibGUsXG4gICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgZXhwYW5kZWQsXG4gICAgICAgICAgZXhwYW5kUm93LFxuICAgICAgICAgIHNlbGVjdFJvdyxcbiAgICAgICAgICBjZWxsRWRpdDoge1xuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIERCQ0xJQ0tfVE9fQ0VMTF9FRElULFxuICAgICAgICAgICAgREVMQVlfRk9SX0RCQ0xJQ0tcbiAgICAgICAgICB9XG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGNvbnN0IGNsaWNrRm4gPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihlLCByb3csIHJvd0luZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qga2V5ID0gXy5nZXQocm93LCBrZXlGaWVsZCk7XG4gICAgICAgICAgaWYgKGV4cGFuZFJvdyAmJiBleHBhbmRhYmxlKSB7XG4gICAgICAgICAgICBleHBhbmRSb3cub25Sb3dFeHBhbmQoa2V5LCAhZXhwYW5kZWQsIHJvd0luZGV4LCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGVjdFJvdy5tb2RlICE9PSBDb25zdC5ST1dfU0VMRUNUX0RJU0FCTEVEICYmIHNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHNlbGVjdFJvdy5vblJvd1NlbGVjdChrZXksICFzZWxlY3RlZCwgcm93SW5kZXgsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobW9kZSA9PT0gREJDTElDS19UT19DRUxMX0VESVQgJiYgc2VsZWN0Um93LmNsaWNrVG9FZGl0KSB7XG4gICAgICAgICAgdGhpcy5jbGlja051bSArPSAxO1xuICAgICAgICAgIF8uZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpY2tOdW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgY2xpY2tGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGlja051bSA9IDA7XG4gICAgICAgICAgfSwgREVMQVlfRk9SX0RCQ0xJQ0spKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpY2tGbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlbGVnYXRlKGF0dHJzID0ge30pIHtcbiAgICAgIGNvbnN0IG5ld0F0dHJzID0ge307XG4gICAgICBjb25zdCB7IGV4cGFuZFJvdywgc2VsZWN0Um93IH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKGV4cGFuZFJvdyB8fCAoc2VsZWN0Um93ICYmIHNlbGVjdFJvdy5jbGlja1RvU2VsZWN0KSkge1xuICAgICAgICBuZXdBdHRycy5vbkNsaWNrID0gdGhpcy5jcmVhdGVDbGlja0V2ZW50SGFuZGxlcihhdHRycy5vbkNsaWNrKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgIGlmICghbmV3QXR0cnNbYXR0cl0pIHtcbiAgICAgICAgICBpZiAoZXZlbnRzLmluY2x1ZGVzKGF0dHIpKSB7XG4gICAgICAgICAgICBuZXdBdHRyc1thdHRyXSA9IHRoaXMuY3JlYXRlRGVmYXVsdEV2ZW50SGFuZGxlcihhdHRyc1thdHRyXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0F0dHJzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdBdHRycztcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9yb3ctZXZlbnQtZGVsZWdhdGVyLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IEV4cGFuZFJvdyA9ICh7IGNoaWxkcmVuLCAuLi5yZXN0IH0pID0+IChcbiAgPHRyIGNsYXNzTmFtZT1cImV4cGFuZGluZy1yb3dcIj5cbiAgICA8dGQgeyAuLi5yZXN0IH0+eyBjaGlsZHJlbiB9PC90ZD5cbiAgPC90cj5cbik7XG5cbkV4cGFuZFJvdy5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuRXhwYW5kUm93LmRlZmF1bHRQcm9wcyA9IHtcbiAgY2hpbGRyZW46IG51bGxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEV4cGFuZFJvdztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3Jvdy1leHBhbmQvZXhwYW5kLXJvdy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jb25zdCBSb3dTZWN0aW9uID0gKHsgY29udGVudCwgY29sU3BhbiB9KSA9PiAoXG4gIDx0cj5cbiAgICA8dGRcbiAgICAgIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgY29sU3Bhbj17IGNvbFNwYW4gfVxuICAgICAgY2xhc3NOYW1lPVwicmVhY3QtYnMtdGFibGUtbm8tZGF0YVwiXG4gICAgPlxuICAgICAgeyBjb250ZW50IH1cbiAgICA8L3RkPlxuICA8L3RyPlxuKTtcblxuUm93U2VjdGlvbi5wcm9wVHlwZXMgPSB7XG4gIGNvbnRlbnQ6IFByb3BUeXBlcy5hbnksXG4gIGNvbFNwYW46IFByb3BUeXBlcy5udW1iZXJcbn07XG5cblJvd1NlY3Rpb24uZGVmYXVsdFByb3BzID0ge1xuICBjb250ZW50OiBudWxsLFxuICBjb2xTcGFuOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSb3dTZWN0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvcm93LXNlY3Rpb24uanMiLCJpbXBvcnQgQ29sdW1uUmVzb2x2ZXIgZnJvbSAnLi9jb2x1bW4tcmVzb2x2ZXInO1xuaW1wb3J0IEV4cGFuZFJvd1Jlc29sdmVyIGZyb20gJy4vZXhwYW5kLXJvdy1yZXNvbHZlcic7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vY29uc3QnO1xuaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIFRhYmxlUmVzb2x2ZXIgZXh0ZW5kc1xuICAgIEV4cGFuZFJvd1Jlc29sdmVyKENvbHVtblJlc29sdmVyKEV4dGVuZEJhc2UpKSB7XG4gICAgdmFsaWRhdGVQcm9wcygpIHtcbiAgICAgIGNvbnN0IHsga2V5RmllbGQgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIWtleUZpZWxkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHNwZWNpZnkgYSBmaWVsZCBhcyBrZXkgdmlhIGtleUZpZWxkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy52aXNpYmxlQ29sdW1uU2l6ZShmYWxzZSkgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZpc2libGUgY29sdW1ucyBkZXRlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5kYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wcyByZXNvbHZlciBmb3IgY2VsbCBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGFkZHRpb25hbCBvcHRpb25zIGxpa2UgY2FsbGJhY2sgd2hpY2ggYXJlIGFib3V0IHRvIG1lcmdlIGludG8gcHJvcHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCAtIHByb3BzIGZvciBjZWxsIHNlbGVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHQubW9kZSAtIGlucHV0IHR5cGUgb2Ygcm93IHNlbGVjdGlvbiBvciBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICByZXNvbHZlU2VsZWN0Um93UHJvcHMob3B0aW9ucykge1xuICAgICAgY29uc3QgeyBzZWxlY3RSb3cgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IFJPV19TRUxFQ1RfRElTQUJMRUQgfSA9IENvbnN0O1xuXG4gICAgICBpZiAoXy5pc0RlZmluZWQoc2VsZWN0Um93KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNlbGVjdFJvdyxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGU6IFJPV19TRUxFQ1RfRElTQUJMRURcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJvcHMgcmVzb2x2ZXIgZm9yIGhlYWRlciBjZWxsIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkdGlvbmFsIG9wdGlvbnMgbGlrZSBjYWxsYmFjayB3aGljaCBhcmUgYWJvdXQgdG8gbWVyZ2UgaW50byBwcm9wc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVzdWx0IC0gcHJvcHMgZm9yIGNlbGwgc2VsZWN0aW9uc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdC5tb2RlIC0gaW5wdXQgdHlwZSBvZiByb3cgc2VsZWN0aW9uIG9yIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdC5jaGVja2VkU3RhdHVzIC0gY2hlY2tib3ggc3RhdHVzIGRlcGVuZGluZyBvbiBzZWxlY3RlZCByb3dzIGNvdW50c1xuICAgICAqL1xuICAgIHJlc29sdmVTZWxlY3RSb3dQcm9wc0ZvckhlYWRlcihvcHRpb25zID0ge30pIHtcbiAgICAgIGNvbnN0IHsgc2VsZWN0Um93IH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgeyBhbGxSb3dzU2VsZWN0ZWQsIGFsbFJvd3NOb3RTZWxlY3RlZCwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgUk9XX1NFTEVDVF9ESVNBQkxFRCwgQ0hFQ0tCT1hfU1RBVFVTX0NIRUNLRUQsXG4gICAgICAgIENIRUNLQk9YX1NUQVRVU19JTkRFVEVSTUlOQVRFLCBDSEVDS0JPWF9TVEFUVVNfVU5DSEVDS0VEXG4gICAgICB9ID0gQ29uc3Q7XG5cbiAgICAgIGlmIChfLmlzRGVmaW5lZChzZWxlY3RSb3cpKSB7XG4gICAgICAgIGxldCBjaGVja2VkU3RhdHVzO1xuXG4gICAgICAgIC8vIGNoZWNrYm94IHN0YXR1cyBkZXBlbmRpbmcgb24gc2VsZWN0ZWQgcm93cyBjb3VudHNcbiAgICAgICAgaWYgKGFsbFJvd3NTZWxlY3RlZCkgY2hlY2tlZFN0YXR1cyA9IENIRUNLQk9YX1NUQVRVU19DSEVDS0VEO1xuICAgICAgICBlbHNlIGlmIChhbGxSb3dzTm90U2VsZWN0ZWQpIGNoZWNrZWRTdGF0dXMgPSBDSEVDS0JPWF9TVEFUVVNfVU5DSEVDS0VEO1xuICAgICAgICBlbHNlIGNoZWNrZWRTdGF0dXMgPSBDSEVDS0JPWF9TVEFUVVNfSU5ERVRFUk1JTkFURTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnNlbGVjdFJvdyxcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIGNoZWNrZWRTdGF0dXNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kZTogUk9XX1NFTEVDVF9ESVNBQkxFRFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9pbmRleC5qcyIsImV4cG9ydCBkZWZhdWx0IEV4dGVuZEJhc2UgPT5cbiAgY2xhc3MgQ29sdW1uUmVzb2x2ZXIgZXh0ZW5kcyBFeHRlbmRCYXNlIHtcbiAgICB2aXNpYmxlQ29sdW1uU2l6ZShpbmNsdWRlU2VsZWN0Q29sdW1uID0gdHJ1ZSkge1xuICAgICAgbGV0IGNvbHVtbkxlbiA9IHRoaXMucHJvcHMuY29sdW1ucy5maWx0ZXIoYyA9PiAhYy5oaWRkZW4pLmxlbmd0aDtcbiAgICAgIGlmICghaW5jbHVkZVNlbGVjdENvbHVtbikgcmV0dXJuIGNvbHVtbkxlbjtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdFJvdyAmJiAhdGhpcy5wcm9wcy5zZWxlY3RSb3cuaGlkZVNlbGVjdENvbHVtbikge1xuICAgICAgICBjb2x1bW5MZW4gKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByb3BzLmV4cGFuZFJvdyAmJiB0aGlzLnByb3BzLmV4cGFuZFJvdy5zaG93RXhwYW5kQ29sdW1uKSB7XG4gICAgICAgIGNvbHVtbkxlbiArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbkxlbjtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9jb2x1bW4tcmVzb2x2ZXIuanMiLCJleHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIEV4cGFuZFJvd1Jlc29sdmVyIGV4dGVuZHMgRXh0ZW5kQmFzZSB7XG4gICAgcmVzb2x2ZUV4cGFuZFJvd1Byb3BzKCkge1xuICAgICAgY29uc3QgeyBleHBhbmRSb3csIGV4cGFuZGVkLCBvblJvd0V4cGFuZCwgb25BbGxSb3dFeHBhbmQsIGlzQW55RXhwYW5kcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmIChleHBhbmRSb3cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5leHBhbmRSb3csXG4gICAgICAgICAgZXhwYW5kZWQsXG4gICAgICAgICAgb25Sb3dFeHBhbmQsXG4gICAgICAgICAgb25BbGxSb3dFeHBhbmQsXG4gICAgICAgICAgaXNBbnlFeHBhbmRzLFxuICAgICAgICAgIG5vbkV4cGFuZGFibGU6IGV4cGFuZFJvdy5ub25FeHBhbmRhYmxlIHx8IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9leHBhbmQtcm93LXJlc29sdmVyLmpzIiwiLyogZXNsaW50IG5vLXJldHVybi1hc3NpZ246IDAgKi9cbi8qIGVzbGludCBjbGFzcy1tZXRob2RzLXVzZS10aGlzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IGNyZWF0ZURhdGFDb250ZXh0IGZyb20gJy4vZGF0YS1jb250ZXh0JztcbmltcG9ydCBjcmVhdGVTb3J0Q29udGV4dCBmcm9tICcuL3NvcnQtY29udGV4dCc7XG5pbXBvcnQgY3JlYXRlU2VsZWN0aW9uQ29udGV4dCBmcm9tICcuL3NlbGVjdGlvbi1jb250ZXh0JztcbmltcG9ydCBjcmVhdGVSb3dFeHBhbmRDb250ZXh0IGZyb20gJy4vcm93LWV4cGFuZC1jb250ZXh0JztcbmltcG9ydCByZW1vdGVSZXNvbHZlciBmcm9tICcuLi9wcm9wcy1yZXNvbHZlci9yZW1vdGUtcmVzb2x2ZXInO1xuaW1wb3J0IHsgQm9vdHN0cmFwQ29udGV4dCB9IGZyb20gJy4vYm9vdHN0cmFwJztcbmltcG9ydCBkYXRhT3BlcmF0b3IgZnJvbSAnLi4vc3RvcmUvb3BlcmF0b3JzJztcblxuY29uc3Qgd2l0aENvbnRleHQgPSBCYXNlID0+XG4gIGNsYXNzIEJvb3RzdHJhcFRhYmxlQ29udGFpbmVyIGV4dGVuZHMgcmVtb3RlUmVzb2x2ZXIoQ29tcG9uZW50KSB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuRGF0YUNvbnRleHQgPSBjcmVhdGVEYXRhQ29udGV4dCgpO1xuXG4gICAgICBpZiAocHJvcHMuY29sdW1ucy5maWx0ZXIoY29sID0+IGNvbC5zb3J0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuU29ydENvbnRleHQgPSBjcmVhdGVTb3J0Q29udGV4dChcbiAgICAgICAgICBkYXRhT3BlcmF0b3IsIHRoaXMuaXNSZW1vdGVTb3J0LCB0aGlzLmhhbmRsZVJlbW90ZVNvcnRDaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMuc2VsZWN0Um93KSB7XG4gICAgICAgIHRoaXMuU2VsZWN0aW9uQ29udGV4dCA9IGNyZWF0ZVNlbGVjdGlvbkNvbnRleHQoZGF0YU9wZXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLmV4cGFuZFJvdykge1xuICAgICAgICB0aGlzLlJvd0V4cGFuZENvbnRleHQgPSBjcmVhdGVSb3dFeHBhbmRDb250ZXh0KGRhdGFPcGVyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5jZWxsRWRpdCAmJiBwcm9wcy5jZWxsRWRpdC5jcmVhdGVDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuQ2VsbEVkaXRDb250ZXh0ID0gcHJvcHMuY2VsbEVkaXQuY3JlYXRlQ29udGV4dChcbiAgICAgICAgICBfLCBkYXRhT3BlcmF0b3IsIHRoaXMuaXNSZW1vdGVDZWxsRWRpdCwgdGhpcy5oYW5kbGVSZW1vdGVDZWxsQ2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLmZpbHRlcikge1xuICAgICAgICB0aGlzLkZpbHRlckNvbnRleHQgPSBwcm9wcy5maWx0ZXIuY3JlYXRlQ29udGV4dChcbiAgICAgICAgICBfLCB0aGlzLmlzUmVtb3RlRmlsdGVyaW5nLCB0aGlzLmhhbmRsZVJlbW90ZUZpbHRlckNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5wYWdpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMuUGFnaW5hdGlvbkNvbnRleHQgPSBwcm9wcy5wYWdpbmF0aW9uLmNyZWF0ZUNvbnRleHQoXG4gICAgICAgICAgdGhpcy5pc1JlbW90ZVBhZ2luYXRpb24sIHRoaXMuaGFuZGxlUmVtb3RlUGFnZUNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5zZWFyY2ggJiYgcHJvcHMuc2VhcmNoLnNlYXJjaENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5TZWFyY2hDb250ZXh0ID0gcHJvcHMuc2VhcmNoLnNlYXJjaENvbnRleHQoXG4gICAgICAgICAgXywgdGhpcy5pc1JlbW90ZVNlYXJjaCwgdGhpcy5oYW5kbGVSZW1vdGVTZWFyY2hDaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMuc2V0RGVwZW5kZW5jeU1vZHVsZXMpIHtcbiAgICAgICAgcHJvcHMuc2V0RGVwZW5kZW5jeU1vZHVsZXMoXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyQmFzZSgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJvb3RQcm9wcyxcbiAgICAgICAgY2VsbEVkaXRQcm9wcyxcbiAgICAgICAgZmlsdGVyUHJvcHMsXG4gICAgICAgIHNlYXJjaFByb3BzLFxuICAgICAgICBzb3J0UHJvcHMsXG4gICAgICAgIHBhZ2luYXRpb25Qcm9wcyxcbiAgICAgICAgZXhwYW5kUHJvcHMsXG4gICAgICAgIHNlbGVjdGlvblByb3BzXG4gICAgICApID0+IChcbiAgICAgICAgPEJhc2VcbiAgICAgICAgICB7IC4uLnRoaXMucHJvcHMgfVxuICAgICAgICAgIHsgLi4uc2VsZWN0aW9uUHJvcHMgfVxuICAgICAgICAgIHsgLi4uc29ydFByb3BzIH1cbiAgICAgICAgICB7IC4uLmNlbGxFZGl0UHJvcHMgfVxuICAgICAgICAgIHsgLi4uZmlsdGVyUHJvcHMgfVxuICAgICAgICAgIHsgLi4uc2VhcmNoUHJvcHMgfVxuICAgICAgICAgIHsgLi4ucGFnaW5hdGlvblByb3BzIH1cbiAgICAgICAgICB7IC4uLmV4cGFuZFByb3BzIH1cbiAgICAgICAgICBkYXRhPXsgcm9vdFByb3BzLmdldERhdGEoZmlsdGVyUHJvcHMsIHNlYXJjaFByb3BzLCBzb3J0UHJvcHMsIHBhZ2luYXRpb25Qcm9wcykgfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJXaXRoU2VsZWN0aW9uQ3R4KGJhc2UsIGJhc2VQcm9wcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgc2VhcmNoUHJvcHMsXG4gICAgICAgIHNvcnRQcm9wcyxcbiAgICAgICAgcGFnaW5hdGlvblByb3BzLFxuICAgICAgICBleHBhbmRQcm9wc1xuICAgICAgKSA9PiAoXG4gICAgICAgIDx0aGlzLlNlbGVjdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICB7IC4uLmJhc2VQcm9wcyB9XG4gICAgICAgICAgc2VsZWN0Um93PXsgdGhpcy5wcm9wcy5zZWxlY3RSb3cgfVxuICAgICAgICAgIGRhdGE9eyByb290UHJvcHMuZ2V0RGF0YShmaWx0ZXJQcm9wcywgc2VhcmNoUHJvcHMsIHNvcnRQcm9wcywgcGFnaW5hdGlvblByb3BzKSB9XG4gICAgICAgID5cbiAgICAgICAgICA8dGhpcy5TZWxlY3Rpb25Db250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25Qcm9wcyA9PiBiYXNlKFxuICAgICAgICAgICAgICAgIHJvb3RQcm9wcyxcbiAgICAgICAgICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICAgICAgICAgIGZpbHRlclByb3BzLFxuICAgICAgICAgICAgICAgIHNlYXJjaFByb3BzLFxuICAgICAgICAgICAgICAgIHNvcnRQcm9wcyxcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uUHJvcHMsXG4gICAgICAgICAgICAgICAgZXhwYW5kUHJvcHMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uUHJvcHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvdGhpcy5TZWxlY3Rpb25Db250ZXh0LkNvbnN1bWVyPlxuICAgICAgICA8L3RoaXMuU2VsZWN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyV2l0aFJvd0V4cGFuZEN0eChiYXNlLCBiYXNlUHJvcHMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJvb3RQcm9wcyxcbiAgICAgICAgY2VsbEVkaXRQcm9wcyxcbiAgICAgICAgZmlsdGVyUHJvcHMsXG4gICAgICAgIHNlYXJjaFByb3BzLFxuICAgICAgICBzb3J0UHJvcHMsXG4gICAgICAgIHBhZ2luYXRpb25Qcm9wc1xuICAgICAgKSA9PiAoXG4gICAgICAgIDx0aGlzLlJvd0V4cGFuZENvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICB7IC4uLmJhc2VQcm9wcyB9XG4gICAgICAgICAgZXhwYW5kUm93PXsgdGhpcy5wcm9wcy5leHBhbmRSb3cgfVxuICAgICAgICAgIGRhdGE9eyByb290UHJvcHMuZ2V0RGF0YShmaWx0ZXJQcm9wcywgc2VhcmNoUHJvcHMsIHNvcnRQcm9wcywgcGFnaW5hdGlvblByb3BzKSB9XG4gICAgICAgID5cbiAgICAgICAgICA8dGhpcy5Sb3dFeHBhbmRDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBleHBhbmRQcm9wcyA9PiBiYXNlKFxuICAgICAgICAgICAgICAgIHJvb3RQcm9wcyxcbiAgICAgICAgICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICAgICAgICAgIGZpbHRlclByb3BzLFxuICAgICAgICAgICAgICAgIHNlYXJjaFByb3BzLFxuICAgICAgICAgICAgICAgIHNvcnRQcm9wcyxcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uUHJvcHMsXG4gICAgICAgICAgICAgICAgZXhwYW5kUHJvcHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvdGhpcy5Sb3dFeHBhbmRDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICA8L3RoaXMuUm93RXhwYW5kQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyV2l0aFBhZ2luYXRpb25DdHgoYmFzZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgc2VhcmNoUHJvcHMsXG4gICAgICAgIHNvcnRQcm9wc1xuICAgICAgKSA9PiAoXG4gICAgICAgIDx0aGlzLlBhZ2luYXRpb25Db250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgcmVmPXsgbiA9PiB0aGlzLnBhZ2luYXRpb25Db250ZXh0ID0gbiB9XG4gICAgICAgICAgcGFnaW5hdGlvbj17IHRoaXMucHJvcHMucGFnaW5hdGlvbiB9XG4gICAgICAgICAgZGF0YT17IHJvb3RQcm9wcy5nZXREYXRhKGZpbHRlclByb3BzLCBzZWFyY2hQcm9wcywgc29ydFByb3BzKSB9XG4gICAgICAgICAgYm9vdHN0cmFwND17IHRoaXMucHJvcHMuYm9vdHN0cmFwNCB9XG4gICAgICAgID5cbiAgICAgICAgICA8dGhpcy5QYWdpbmF0aW9uQ29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGFnaW5hdGlvblByb3BzID0+IGJhc2UoXG4gICAgICAgICAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICAgICAgICAgIGNlbGxFZGl0UHJvcHMsXG4gICAgICAgICAgICAgICAgZmlsdGVyUHJvcHMsXG4gICAgICAgICAgICAgICAgc2VhcmNoUHJvcHMsXG4gICAgICAgICAgICAgICAgc29ydFByb3BzLFxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25Qcm9wc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC90aGlzLlBhZ2luYXRpb25Db250ZXh0LkNvbnN1bWVyPlxuICAgICAgICA8L3RoaXMuUGFnaW5hdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcldpdGhTb3J0Q3R4KGJhc2UsIGJhc2VQcm9wcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICBjZWxsRWRpdFByb3BzLFxuICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgc2VhcmNoUHJvcHNcbiAgICAgICkgPT4gKFxuICAgICAgICA8dGhpcy5Tb3J0Q29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHsgLi4uYmFzZVByb3BzIH1cbiAgICAgICAgICByZWY9eyBuID0+IHRoaXMuc29ydENvbnRleHQgPSBuIH1cbiAgICAgICAgICBkZWZhdWx0U29ydGVkPXsgdGhpcy5wcm9wcy5kZWZhdWx0U29ydGVkIH1cbiAgICAgICAgICBkZWZhdWx0U29ydERpcmVjdGlvbj17IHRoaXMucHJvcHMuZGVmYXVsdFNvcnREaXJlY3Rpb24gfVxuICAgICAgICAgIGRhdGE9eyByb290UHJvcHMuZ2V0RGF0YShmaWx0ZXJQcm9wcywgc2VhcmNoUHJvcHMpIH1cbiAgICAgICAgPlxuICAgICAgICAgIDx0aGlzLlNvcnRDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzb3J0UHJvcHMgPT4gYmFzZShcbiAgICAgICAgICAgICAgICByb290UHJvcHMsXG4gICAgICAgICAgICAgICAgY2VsbEVkaXRQcm9wcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgICAgICAgICBzZWFyY2hQcm9wcyxcbiAgICAgICAgICAgICAgICBzb3J0UHJvcHMsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L3RoaXMuU29ydENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIDwvdGhpcy5Tb3J0Q29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyV2l0aFNlYXJjaEN0eChiYXNlLCBiYXNlUHJvcHMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJvb3RQcm9wcyxcbiAgICAgICAgY2VsbEVkaXRQcm9wcyxcbiAgICAgICAgZmlsdGVyUHJvcHNcbiAgICAgICkgPT4gKFxuICAgICAgICA8dGhpcy5TZWFyY2hDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgeyAuLi5iYXNlUHJvcHMgfVxuICAgICAgICAgIHJlZj17IG4gPT4gdGhpcy5zZWFyY2hDb250ZXh0ID0gbiB9XG4gICAgICAgICAgZGF0YT17IHJvb3RQcm9wcy5nZXREYXRhKGZpbHRlclByb3BzKSB9XG4gICAgICAgICAgc2VhcmNoVGV4dD17IHRoaXMucHJvcHMuc2VhcmNoLnNlYXJjaFRleHQgfVxuICAgICAgICA+XG4gICAgICAgICAgPHRoaXMuU2VhcmNoQ29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2VhcmNoUHJvcHMgPT4gYmFzZShcbiAgICAgICAgICAgICAgICByb290UHJvcHMsXG4gICAgICAgICAgICAgICAgY2VsbEVkaXRQcm9wcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJQcm9wcyxcbiAgICAgICAgICAgICAgICBzZWFyY2hQcm9wc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC90aGlzLlNlYXJjaENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIDwvdGhpcy5TZWFyY2hDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZW5kZXJXaXRoRmlsdGVyQ3R4KGJhc2UsIGJhc2VQcm9wcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICBjZWxsRWRpdFByb3BzXG4gICAgICApID0+IChcbiAgICAgICAgPHRoaXMuRmlsdGVyQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHsgLi4uYmFzZVByb3BzIH1cbiAgICAgICAgICByZWY9eyBuID0+IHRoaXMuZmlsdGVyQ29udGV4dCA9IG4gfVxuICAgICAgICAgIGRhdGE9eyByb290UHJvcHMuZ2V0RGF0YSgpIH1cbiAgICAgICAgPlxuICAgICAgICAgIDx0aGlzLkZpbHRlckNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZpbHRlclByb3BzID0+IGJhc2UoXG4gICAgICAgICAgICAgICAgcm9vdFByb3BzLFxuICAgICAgICAgICAgICAgIGNlbGxFZGl0UHJvcHMsXG4gICAgICAgICAgICAgICAgZmlsdGVyUHJvcHNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvdGhpcy5GaWx0ZXJDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICA8L3RoaXMuRmlsdGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyV2l0aENlbGxFZGl0Q3R4KGJhc2UsIGJhc2VQcm9wcykge1xuICAgICAgcmV0dXJuIHJvb3RQcm9wcyA9PiAoXG4gICAgICAgIDx0aGlzLkNlbGxFZGl0Q29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHsgLi4uYmFzZVByb3BzIH1cbiAgICAgICAgICBzZWxlY3RSb3c9eyB0aGlzLnByb3BzLnNlbGVjdFJvdyB9XG4gICAgICAgICAgY2VsbEVkaXQ9eyB0aGlzLnByb3BzLmNlbGxFZGl0IH1cbiAgICAgICAgICBkYXRhPXsgcm9vdFByb3BzLmdldERhdGEoKSB9XG4gICAgICAgID5cbiAgICAgICAgICA8dGhpcy5DZWxsRWRpdENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNlbGxFZGl0UHJvcHMgPT4gYmFzZShyb290UHJvcHMsIGNlbGxFZGl0UHJvcHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC90aGlzLkNlbGxFZGl0Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgPC90aGlzLkNlbGxFZGl0Q29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyBrZXlGaWVsZCwgY29sdW1ucywgYm9vdHN0cmFwNCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGJhc2VQcm9wcyA9IHsga2V5RmllbGQsIGNvbHVtbnMgfTtcblxuICAgICAgbGV0IGJhc2UgPSB0aGlzLnJlbmRlckJhc2UoKTtcblxuICAgICAgaWYgKHRoaXMuU2VsZWN0aW9uQ29udGV4dCkge1xuICAgICAgICBiYXNlID0gdGhpcy5yZW5kZXJXaXRoU2VsZWN0aW9uQ3R4KGJhc2UsIGJhc2VQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLlJvd0V4cGFuZENvbnRleHQpIHtcbiAgICAgICAgYmFzZSA9IHRoaXMucmVuZGVyV2l0aFJvd0V4cGFuZEN0eChiYXNlLCBiYXNlUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5QYWdpbmF0aW9uQ29udGV4dCkge1xuICAgICAgICBiYXNlID0gdGhpcy5yZW5kZXJXaXRoUGFnaW5hdGlvbkN0eChiYXNlLCBiYXNlUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5Tb3J0Q29udGV4dCkge1xuICAgICAgICBiYXNlID0gdGhpcy5yZW5kZXJXaXRoU29ydEN0eChiYXNlLCBiYXNlUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5TZWFyY2hDb250ZXh0KSB7XG4gICAgICAgIGJhc2UgPSB0aGlzLnJlbmRlcldpdGhTZWFyY2hDdHgoYmFzZSwgYmFzZVByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuRmlsdGVyQ29udGV4dCkge1xuICAgICAgICBiYXNlID0gdGhpcy5yZW5kZXJXaXRoRmlsdGVyQ3R4KGJhc2UsIGJhc2VQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLkNlbGxFZGl0Q29udGV4dCkge1xuICAgICAgICBiYXNlID0gdGhpcy5yZW5kZXJXaXRoQ2VsbEVkaXRDdHgoYmFzZSwgYmFzZVByb3BzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEJvb3RzdHJhcENvbnRleHQuUHJvdmlkZXIgdmFsdWU9eyB7IGJvb3RzdHJhcDQgfSB9PlxuICAgICAgICAgIDx0aGlzLkRhdGFDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgICB7IC4uLmJhc2VQcm9wcyB9XG4gICAgICAgICAgICBkYXRhPXsgdGhpcy5wcm9wcy5kYXRhIH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8dGhpcy5EYXRhQ29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJhc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC90aGlzLkRhdGFDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgIDwvdGhpcy5EYXRhQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9Cb290c3RyYXBDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhDb250ZXh0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGV4dHMvaW5kZXguanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuICBjb25zdCBEYXRhQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoKTtcblxuICBjbGFzcyBEYXRhUHJvdmlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkXG4gICAgfVxuXG4gICAgc3RhdGUgPSB7IGRhdGE6IHRoaXMucHJvcHMuZGF0YSB9O1xuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgZGF0YTogbmV4dFByb3BzLmRhdGEgfSkpO1xuICAgIH1cblxuICAgIGdldERhdGEgPSAoZmlsdGVyUHJvcHMsIHNlYXJjaFByb3BzLCBzb3J0UHJvcHMsIHBhZ2luYXRpb25Qcm9wcykgPT4ge1xuICAgICAgaWYgKHBhZ2luYXRpb25Qcm9wcykgcmV0dXJuIHBhZ2luYXRpb25Qcm9wcy5kYXRhO1xuICAgICAgZWxzZSBpZiAoc29ydFByb3BzKSByZXR1cm4gc29ydFByb3BzLmRhdGE7XG4gICAgICBlbHNlIGlmIChzZWFyY2hQcm9wcykgcmV0dXJuIHNlYXJjaFByb3BzLmRhdGE7XG4gICAgICBlbHNlIGlmIChmaWx0ZXJQcm9wcykgcmV0dXJuIGZpbHRlclByb3BzLmRhdGE7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5kYXRhO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxEYXRhQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHZhbHVlPXsge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgICAgICAgZ2V0RGF0YTogdGhpcy5nZXREYXRhXG4gICAgICAgICAgfSB9XG4gICAgICAgID5cbiAgICAgICAgICB7IHRoaXMucHJvcHMuY2hpbGRyZW4gfVxuICAgICAgICA8L0RhdGFDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBQcm92aWRlcjogRGF0YVByb3ZpZGVyLFxuICAgIENvbnN1bWVyOiBEYXRhQ29udGV4dC5Db25zdW1lclxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL2NvbnRleHRzL2RhdGEtY29udGV4dC5qcyIsIi8qIGVzbGludCByZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcblxuZXhwb3J0IGRlZmF1bHQgKFxuICBkYXRhT3BlcmF0b3IsXG4gIGlzUmVtb3RlU29ydCxcbiAgaGFuZGxlU29ydENoYW5nZVxuKSA9PiB7XG4gIGNvbnN0IFNvcnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xuXG4gIGNsYXNzIFNvcnRQcm92aWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAgICAgY29sdW1uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICAgIGRlZmF1bHRTb3J0ZWQ6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgIGRhdGFGaWVsZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgICBvcmRlcjogUHJvcFR5cGVzLm9uZU9mKFtDb25zdC5TT1JUX0RFU0MsIENvbnN0LlNPUlRfQVNDXSkuaXNSZXF1aXJlZFxuICAgICAgfSkpLFxuICAgICAgZGVmYXVsdFNvcnREaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbQ29uc3QuU09SVF9ERVNDLCBDb25zdC5TT1JUX0FTQ10pXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgIGxldCBzb3J0T3JkZXI7XG4gICAgICBsZXQgc29ydENvbHVtbjtcbiAgICAgIGNvbnN0IHsgY29sdW1ucywgZGVmYXVsdFNvcnRlZCwgZGVmYXVsdFNvcnREaXJlY3Rpb24gfSA9IHByb3BzO1xuXG4gICAgICBpZiAoZGVmYXVsdFNvcnRlZCAmJiBkZWZhdWx0U29ydGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc29ydEZpZWxkID0gZGVmYXVsdFNvcnRlZFswXS5kYXRhRmllbGQ7XG4gICAgICAgIHNvcnRPcmRlciA9IGRlZmF1bHRTb3J0ZWRbMF0ub3JkZXIgfHwgZGVmYXVsdFNvcnREaXJlY3Rpb247XG4gICAgICAgIGNvbnN0IHNvcnRDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoY29sID0+IGNvbC5kYXRhRmllbGQgPT09IHNvcnRGaWVsZCk7XG4gICAgICAgIGlmIChzb3J0Q29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc29ydENvbHVtbiA9IHNvcnRDb2x1bW5zWzBdO1xuXG4gICAgICAgICAgaWYgKHNvcnRDb2x1bW4ub25Tb3J0KSB7XG4gICAgICAgICAgICBzb3J0Q29sdW1uLm9uU29ydChzb3J0RmllbGQsIHNvcnRPcmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0geyBzb3J0T3JkZXIsIHNvcnRDb2x1bW4gfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGNvbnN0IHsgc29ydE9yZGVyLCBzb3J0Q29sdW1uIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKGlzUmVtb3RlU29ydCgpICYmIHNvcnRPcmRlciAmJiBzb3J0Q29sdW1uKSB7XG4gICAgICAgIGhhbmRsZVNvcnRDaGFuZ2Uoc29ydENvbHVtbi5kYXRhRmllbGQsIHNvcnRPcmRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlU29ydCA9IChjb2x1bW4pID0+IHtcbiAgICAgIGNvbnN0IHNvcnRPcmRlciA9IGRhdGFPcGVyYXRvci5uZXh0T3JkZXIoY29sdW1uLCB0aGlzLnN0YXRlLCB0aGlzLnByb3BzLmRlZmF1bHRTb3J0RGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGNvbHVtbi5vblNvcnQpIHtcbiAgICAgICAgY29sdW1uLm9uU29ydChjb2x1bW4uZGF0YUZpZWxkLCBzb3J0T3JkZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNSZW1vdGVTb3J0KCkpIHtcbiAgICAgICAgaGFuZGxlU29ydENoYW5nZShjb2x1bW4uZGF0YUZpZWxkLCBzb3J0T3JkZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICBzb3J0T3JkZXIsXG4gICAgICAgIHNvcnRDb2x1bW46IGNvbHVtblxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIGxldCB7IGRhdGEgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IHNvcnRPcmRlciwgc29ydENvbHVtbiB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmICghaXNSZW1vdGVTb3J0KCkgJiYgc29ydENvbHVtbikge1xuICAgICAgICBkYXRhID0gZGF0YU9wZXJhdG9yLnNvcnQoZGF0YSwgc29ydE9yZGVyLCBzb3J0Q29sdW1uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFNvcnRDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgdmFsdWU9eyB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc29ydE9yZGVyLFxuICAgICAgICAgICAgb25Tb3J0OiB0aGlzLmhhbmRsZVNvcnQsXG4gICAgICAgICAgICBzb3J0RmllbGQ6IHNvcnRDb2x1bW4gPyBzb3J0Q29sdW1uLmRhdGFGaWVsZCA6IG51bGxcbiAgICAgICAgICB9IH1cbiAgICAgICAgPlxuICAgICAgICAgIHsgdGhpcy5wcm9wcy5jaGlsZHJlbiB9XG4gICAgICAgIDwvU29ydENvbnRleHQuUHJvdmlkZXI+XG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBTb3J0UHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IFNvcnRDb250ZXh0LkNvbnN1bWVyXG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGV4dHMvc29ydC1jb250ZXh0LmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL2NvbnN0JztcblxuZXhwb3J0IGRlZmF1bHQgKFxuICBkYXRhT3BlcmF0b3JcbikgPT4ge1xuICBjb25zdCBTZWxlY3Rpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xuXG4gIGNsYXNzIFNlbGVjdGlvblByb3ZpZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gICAgICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgICAgIGtleUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICB9XG5cbiAgICBzdGF0ZSA9IHsgc2VsZWN0ZWQ6ICh0aGlzLnByb3BzLnNlbGVjdFJvdyAmJiB0aGlzLnByb3BzLnNlbGVjdFJvdy5zZWxlY3RlZCkgfHwgW10gfTtcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLnNlbGVjdFJvdykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7XG4gICAgICAgICAgc2VsZWN0ZWQ6IG5leHRQcm9wcy5zZWxlY3RSb3cuc2VsZWN0ZWQgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlUm93U2VsZWN0ID0gKHJvd0tleSwgY2hlY2tlZCwgcm93SW5kZXgsIGUpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwga2V5RmllbGQsIHNlbGVjdFJvdzogeyBtb2RlLCBvblNlbGVjdCB9IH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgeyBST1dfU0VMRUNUX1NJTkdMRSB9ID0gQ29uc3Q7XG5cbiAgICAgIGxldCBjdXJyU2VsZWN0ZWQgPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3RlZF07XG5cbiAgICAgIGlmIChtb2RlID09PSBST1dfU0VMRUNUX1NJTkdMRSkgeyAvLyB3aGVuIHNlbGVjdCBtb2RlIGlzIHJhZGlvXG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IFtyb3dLZXldO1xuICAgICAgfSBlbHNlIGlmIChjaGVja2VkKSB7IC8vIHdoZW4gc2VsZWN0IG1vZGUgaXMgY2hlY2tib3hcbiAgICAgICAgY3VyclNlbGVjdGVkLnB1c2gocm93S2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IGN1cnJTZWxlY3RlZC5maWx0ZXIodmFsdWUgPT4gdmFsdWUgIT09IHJvd0tleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvblNlbGVjdCkge1xuICAgICAgICBjb25zdCByb3cgPSBkYXRhT3BlcmF0b3IuZ2V0Um93QnlSb3dJZChkYXRhLCBrZXlGaWVsZCwgcm93S2V5KTtcbiAgICAgICAgb25TZWxlY3Qocm93LCBjaGVja2VkLCByb3dJbmRleCwgZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgc2VsZWN0ZWQ6IGN1cnJTZWxlY3RlZCB9KSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQWxsUm93c1NlbGVjdCA9IChlLCBpc1VuU2VsZWN0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIGtleUZpZWxkLFxuICAgICAgICBzZWxlY3RSb3c6IHtcbiAgICAgICAgICBvblNlbGVjdEFsbCxcbiAgICAgICAgICBub25TZWxlY3RhYmxlXG4gICAgICAgIH1cbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgeyBzZWxlY3RlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgbGV0IGN1cnJTZWxlY3RlZDtcblxuICAgICAgaWYgKCFpc1VuU2VsZWN0KSB7XG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IHNlbGVjdGVkLmNvbmNhdChkYXRhT3BlcmF0b3Iuc2VsZWN0YWJsZUtleXMoZGF0YSwga2V5RmllbGQsIG5vblNlbGVjdGFibGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJTZWxlY3RlZCA9IHNlbGVjdGVkLmZpbHRlcihzID0+IHR5cGVvZiBkYXRhLmZpbmQoZCA9PiBkW2tleUZpZWxkXSA9PT0gcykgPT09ICd1bmRlZmluZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uU2VsZWN0QWxsKSB7XG4gICAgICAgIG9uU2VsZWN0QWxsKCFpc1VuU2VsZWN0LCBkYXRhT3BlcmF0b3IuZ2V0U2VsZWN0ZWRSb3dzKGRhdGEsIGtleUZpZWxkLCBjdXJyU2VsZWN0ZWQpLCBlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBzZWxlY3RlZDogY3VyclNlbGVjdGVkIH0pKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8U2VsZWN0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgIHZhbHVlPXsge1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuc3RhdGUuc2VsZWN0ZWQsXG4gICAgICAgICAgICBvblJvd1NlbGVjdDogdGhpcy5oYW5kbGVSb3dTZWxlY3QsXG4gICAgICAgICAgICBvbkFsbFJvd3NTZWxlY3Q6IHRoaXMuaGFuZGxlQWxsUm93c1NlbGVjdFxuICAgICAgICAgIH0gfVxuICAgICAgICA+XG4gICAgICAgICAgeyB0aGlzLnByb3BzLmNoaWxkcmVuIH1cbiAgICAgICAgPC9TZWxlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBQcm92aWRlcjogU2VsZWN0aW9uUHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IFNlbGVjdGlvbkNvbnRleHQuQ29uc3VtZXJcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9jb250ZXh0cy9zZWxlY3Rpb24tY29udGV4dC5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgKFxuICBkYXRhT3BlcmF0b3JcbikgPT4ge1xuICBjb25zdCBSb3dFeHBhbmRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xuXG4gIGNsYXNzIFJvd0V4cGFuZFByb3ZpZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gICAgICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgICAgIGtleUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICB9XG5cbiAgICBzdGF0ZSA9IHsgZXhwYW5kZWQ6IHRoaXMucHJvcHMuZXhwYW5kUm93LmV4cGFuZGVkIHx8IFtdIH07XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5leHBhbmRSb3cpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICAgIGV4cGFuZGVkOiBuZXh0UHJvcHMuZXhwYW5kUm93LmV4cGFuZGVkIHx8IHRoaXMuc3RhdGUuZXhwYW5kZWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVJvd0V4cGFuZCA9IChyb3dLZXksIGV4cGFuZGVkLCByb3dJbmRleCwgZSkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhLCBrZXlGaWVsZCwgZXhwYW5kUm93OiB7IG9uRXhwYW5kIH0gfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIGxldCBjdXJyRXhwYW5kZWQgPSBbLi4udGhpcy5zdGF0ZS5leHBhbmRlZF07XG5cbiAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICBjdXJyRXhwYW5kZWQucHVzaChyb3dLZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyckV4cGFuZGVkID0gY3VyckV4cGFuZGVkLmZpbHRlcih2YWx1ZSA9PiB2YWx1ZSAhPT0gcm93S2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uRXhwYW5kKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IGRhdGFPcGVyYXRvci5nZXRSb3dCeVJvd0lkKGRhdGEsIGtleUZpZWxkLCByb3dLZXkpO1xuICAgICAgICBvbkV4cGFuZChyb3csIGV4cGFuZGVkLCByb3dJbmRleCwgZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGV4cGFuZGVkOiBjdXJyRXhwYW5kZWQgfSkpO1xuICAgIH1cblxuICAgIGhhbmRsZUFsbFJvd0V4cGFuZCA9IChlLCBleHBhbmRBbGwpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAga2V5RmllbGQsXG4gICAgICAgIGV4cGFuZFJvdzoge1xuICAgICAgICAgIG9uRXhwYW5kQWxsLFxuICAgICAgICAgIG5vbkV4cGFuZGFibGVcbiAgICAgICAgfVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IGV4cGFuZGVkIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICBsZXQgY3VyckV4cGFuZGVkO1xuXG4gICAgICBpZiAoZXhwYW5kQWxsKSB7XG4gICAgICAgIGN1cnJFeHBhbmRlZCA9IGV4cGFuZGVkLmNvbmNhdChkYXRhT3BlcmF0b3IuZXhwYW5kYWJsZUtleXMoZGF0YSwga2V5RmllbGQsIG5vbkV4cGFuZGFibGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJFeHBhbmRlZCA9IGV4cGFuZGVkLmZpbHRlcihzID0+IHR5cGVvZiBkYXRhLmZpbmQoZCA9PiBkW2tleUZpZWxkXSA9PT0gcykgPT09ICd1bmRlZmluZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uRXhwYW5kQWxsKSB7XG4gICAgICAgIG9uRXhwYW5kQWxsKGV4cGFuZEFsbCwgZGF0YU9wZXJhdG9yLmdldEV4cGFuZGVkUm93cyhkYXRhLCBrZXlGaWVsZCwgY3VyckV4cGFuZGVkKSwgZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgZXhwYW5kZWQ6IGN1cnJFeHBhbmRlZCB9KSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyBkYXRhLCBrZXlGaWVsZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxSb3dFeHBhbmRDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgdmFsdWU9eyB7XG4gICAgICAgICAgICBpc0FueUV4cGFuZHM6IGRhdGFPcGVyYXRvci5pc0FueUV4cGFuZHMoZGF0YSwga2V5RmllbGQsIHRoaXMuc3RhdGUuZXhwYW5kZWQpLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IHRoaXMuc3RhdGUuZXhwYW5kZWQsXG4gICAgICAgICAgICBvblJvd0V4cGFuZDogdGhpcy5oYW5kbGVSb3dFeHBhbmQsXG4gICAgICAgICAgICBvbkFsbFJvd0V4cGFuZDogdGhpcy5oYW5kbGVBbGxSb3dFeHBhbmRcbiAgICAgICAgICB9IH1cbiAgICAgICAgPlxuICAgICAgICAgIHsgdGhpcy5wcm9wcy5jaGlsZHJlbiB9XG4gICAgICAgIDwvUm93RXhwYW5kQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgUHJvdmlkZXI6IFJvd0V4cGFuZFByb3ZpZGVyLFxuICAgIENvbnN1bWVyOiBSb3dFeHBhbmRDb250ZXh0LkNvbnN1bWVyXG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvY29udGV4dHMvcm93LWV4cGFuZC1jb250ZXh0LmpzIiwiaW1wb3J0IF8gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRCYXNlID0+XG4gIGNsYXNzIFJlbW90ZVJlc29sdmVyIGV4dGVuZHMgRXh0ZW5kQmFzZSB7XG4gICAgZ2V0TmV3ZXN0U3RhdGUgPSAoc3RhdGUgPSB7fSkgPT4ge1xuICAgICAgbGV0IHNvcnRPcmRlcjtcbiAgICAgIGxldCBzb3J0RmllbGQ7XG4gICAgICBsZXQgcGFnZTtcbiAgICAgIGxldCBzaXplUGVyUGFnZTtcbiAgICAgIGxldCBzZWFyY2hUZXh0O1xuICAgICAgbGV0IGZpbHRlcnMgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuc29ydENvbnRleHQpIHtcbiAgICAgICAgc29ydE9yZGVyID0gdGhpcy5zb3J0Q29udGV4dC5zdGF0ZS5zb3J0T3JkZXI7XG4gICAgICAgIHNvcnRGaWVsZCA9IHRoaXMuc29ydENvbnRleHQuc3RhdGUuc29ydENvbHVtbiA/XG4gICAgICAgICAgdGhpcy5zb3J0Q29udGV4dC5zdGF0ZS5zb3J0Q29sdW1uLmRhdGFGaWVsZCA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmlsdGVyQ29udGV4dCkge1xuICAgICAgICBmaWx0ZXJzID0gdGhpcy5maWx0ZXJDb250ZXh0LmN1cnJGaWx0ZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wYWdpbmF0aW9uQ29udGV4dCkge1xuICAgICAgICBwYWdlID0gdGhpcy5wYWdpbmF0aW9uQ29udGV4dC5jdXJyUGFnZTtcbiAgICAgICAgc2l6ZVBlclBhZ2UgPSB0aGlzLnBhZ2luYXRpb25Db250ZXh0LmN1cnJTaXplUGVyUGFnZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2VhcmNoQ29udGV4dCkge1xuICAgICAgICBzZWFyY2hUZXh0ID0gdGhpcy5wcm9wcy5zZWFyY2guc2VhcmNoVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc29ydE9yZGVyLFxuICAgICAgICBzb3J0RmllbGQsXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHNpemVQZXJQYWdlLFxuICAgICAgICBzZWFyY2hUZXh0LFxuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZGF0YTogdGhpcy5wcm9wcy5kYXRhXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlzUmVtb3RlU2VhcmNoID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyByZW1vdGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gcmVtb3RlID09PSB0cnVlIHx8IChfLmlzT2JqZWN0KHJlbW90ZSkgJiYgcmVtb3RlLnNlYXJjaCkgfHwgdGhpcy5pc1JlbW90ZVBhZ2luYXRpb24oKTtcbiAgICB9XG5cbiAgICBpc1JlbW90ZVBhZ2luYXRpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUucGFnaW5hdGlvbik7XG4gICAgfVxuXG4gICAgaXNSZW1vdGVGaWx0ZXJpbmcgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUuZmlsdGVyKSB8fCB0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpO1xuICAgIH1cblxuICAgIGlzUmVtb3RlU29ydCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVtb3RlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIHJlbW90ZSA9PT0gdHJ1ZSB8fCAoXy5pc09iamVjdChyZW1vdGUpICYmIHJlbW90ZS5zb3J0KSB8fCB0aGlzLmlzUmVtb3RlUGFnaW5hdGlvbigpO1xuICAgIH1cblxuICAgIGlzUmVtb3RlQ2VsbEVkaXQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlbW90ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiByZW1vdGUgPT09IHRydWUgfHwgKF8uaXNPYmplY3QocmVtb3RlKSAmJiByZW1vdGUuY2VsbEVkaXQpO1xuICAgIH1cblxuICAgIGhhbmRsZVJlbW90ZVBhZ2VDaGFuZ2UgPSAocGFnZSwgc2l6ZVBlclBhZ2UpID0+IHtcbiAgICAgIHRoaXMucHJvcHMub25UYWJsZUNoYW5nZSgncGFnaW5hdGlvbicsIHRoaXMuZ2V0TmV3ZXN0U3RhdGUoeyBwYWdlLCBzaXplUGVyUGFnZSB9KSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVtb3RlRmlsdGVyQ2hhbmdlID0gKGZpbHRlcnMpID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyBmaWx0ZXJzIH07XG4gICAgICBpZiAodGhpcy5pc1JlbW90ZVBhZ2luYXRpb24oKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5wcm9wcy5wYWdpbmF0aW9uLm9wdGlvbnMgfHwge307XG4gICAgICAgIG5ld1N0YXRlLnBhZ2UgPSBfLmlzRGVmaW5lZChvcHRpb25zLnBhZ2VTdGFydEluZGV4KSA/IG9wdGlvbnMucGFnZVN0YXJ0SW5kZXggOiAxO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5vblRhYmxlQ2hhbmdlKCdmaWx0ZXInLCB0aGlzLmdldE5ld2VzdFN0YXRlKG5ld1N0YXRlKSk7XG4gICAgfVxuXG4gICAgaGFuZGxlUmVtb3RlU29ydENoYW5nZSA9IChzb3J0RmllbGQsIHNvcnRPcmRlcikgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vblRhYmxlQ2hhbmdlKCdzb3J0JywgdGhpcy5nZXROZXdlc3RTdGF0ZSh7IHNvcnRGaWVsZCwgc29ydE9yZGVyIH0pKTtcbiAgICB9XG5cbiAgICBoYW5kbGVSZW1vdGVDZWxsQ2hhbmdlID0gKHJvd0lkLCBkYXRhRmllbGQsIG5ld1ZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBjZWxsRWRpdCA9IHsgcm93SWQsIGRhdGFGaWVsZCwgbmV3VmFsdWUgfTtcbiAgICAgIHRoaXMucHJvcHMub25UYWJsZUNoYW5nZSgnY2VsbEVkaXQnLCB0aGlzLmdldE5ld2VzdFN0YXRlKHsgY2VsbEVkaXQgfSkpO1xuICAgIH1cblxuICAgIGhhbmRsZVJlbW90ZVNlYXJjaENoYW5nZSA9IChzZWFyY2hUZXh0KSA9PiB7XG4gICAgICB0aGlzLnByb3BzLm9uVGFibGVDaGFuZ2UoJ3NlYXJjaCcsIHRoaXMuZ2V0TmV3ZXN0U3RhdGUoeyBzZWFyY2hUZXh0IH0pKTtcbiAgICB9XG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9wcm9wcy1yZXNvbHZlci9yZW1vdGUtcmVzb2x2ZXIuanMiLCJpbXBvcnQgKiBhcyByb3dzIGZyb20gJy4vcm93cyc7XG5pbXBvcnQgKiBhcyBzZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xuaW1wb3J0ICogYXMgZXhwYW5kIGZyb20gJy4vZXhwYW5kJztcbmltcG9ydCAqIGFzIG11dGF0ZSBmcm9tICcuL211dGF0ZSc7XG5pbXBvcnQgKiBhcyBzb3J0IGZyb20gJy4vc29ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLi4ucm93cyxcbiAgLi4uc2VsZWN0aW9uLFxuICAuLi5leHBhbmQsXG4gIC4uLm11dGF0ZSxcbiAgLi4uc29ydFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTIvc3JjL3N0b3JlL29wZXJhdG9ycy5qcyIsImltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFJvd0J5Um93SWQgfSBmcm9tICcuL3Jvd3MnO1xuXG5leHBvcnQgY29uc3QgaXNBbnlFeHBhbmRzID0gKFxuICBkYXRhLFxuICBrZXlGaWVsZCxcbiAgZXhwYW5kZWQgPSBbXVxuKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHJvd0tleSA9IF8uZ2V0KGRhdGFbaV0sIGtleUZpZWxkKTtcbiAgICBpZiAodHlwZW9mIGV4cGFuZGVkLmZpbmQoeCA9PiB4ID09PSByb3dLZXkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHBhbmRhYmxlS2V5cyA9IChkYXRhLCBrZXlGaWVsZCwgc2tpcHMgPSBbXSkgPT4ge1xuICBpZiAoc2tpcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGRhdGEubWFwKHJvdyA9PiBfLmdldChyb3csIGtleUZpZWxkKSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbiAgICAuZmlsdGVyKHJvdyA9PiAhc2tpcHMuaW5jbHVkZXMoXy5nZXQocm93LCBrZXlGaWVsZCkpKVxuICAgIC5tYXAocm93ID0+IF8uZ2V0KHJvdywga2V5RmllbGQpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeHBhbmRlZFJvd3MgPSAoZGF0YSwga2V5RmllbGQsIGV4cGFuZGVkKSA9PlxuICBleHBhbmRlZC5tYXAoayA9PiBnZXRSb3dCeVJvd0lkKGRhdGEsIGtleUZpZWxkLCBrKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyL3NyYy9zdG9yZS9leHBhbmQuanMiLCJpbXBvcnQgXyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBnZXRSb3dCeVJvd0lkIH0gZnJvbSAnLi9yb3dzJztcblxuZXhwb3J0IGNvbnN0IGVkaXRDZWxsID0gKGRhdGEsIGtleUZpZWxkLCByb3dJZCwgZGF0YUZpZWxkLCBuZXdWYWx1ZSkgPT4ge1xuICBjb25zdCByb3cgPSBnZXRSb3dCeVJvd0lkKGRhdGEsIGtleUZpZWxkLCByb3dJZCk7XG4gIGlmIChyb3cpIF8uc2V0KHJvdywgZGF0YUZpZWxkLCBuZXdWYWx1ZSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvbXV0YXRlLmpzIiwiLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG4vKiBlc2xpbnQgbm8tbG9uZWx5LWlmOiAwICovXG4vKiBlc2xpbnQgbm8tdW5kZXJzY29yZS1kYW5nbGU6IDAgKi9cbmltcG9ydCBfIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi9jb25zdCc7XG5cbmZ1bmN0aW9uIGNvbXBhcmF0b3IoYSwgYikge1xuICBsZXQgcmVzdWx0O1xuICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gYi5sb2NhbGVDb21wYXJlKGEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGEgPiBiID8gLTEgOiAoKGEgPCBiKSA/IDEgOiAwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY29uc3Qgc29ydCA9IChkYXRhLCBzb3J0T3JkZXIsIHsgZGF0YUZpZWxkLCBzb3J0RnVuYyB9KSA9PiB7XG4gIGNvbnN0IF9kYXRhID0gWy4uLmRhdGFdO1xuICBfZGF0YS5zb3J0KChhLCBiKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgdmFsdWVBID0gXy5nZXQoYSwgZGF0YUZpZWxkKTtcbiAgICBsZXQgdmFsdWVCID0gXy5nZXQoYiwgZGF0YUZpZWxkKTtcbiAgICB2YWx1ZUEgPSBfLmlzRGVmaW5lZCh2YWx1ZUEpID8gdmFsdWVBIDogJyc7XG4gICAgdmFsdWVCID0gXy5pc0RlZmluZWQodmFsdWVCKSA/IHZhbHVlQiA6ICcnO1xuXG4gICAgaWYgKHNvcnRGdW5jKSB7XG4gICAgICByZXN1bHQgPSBzb3J0RnVuYyh2YWx1ZUEsIHZhbHVlQiwgc29ydE9yZGVyLCBkYXRhRmllbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc29ydE9yZGVyID09PSBDb25zdC5TT1JUX0RFU0MpIHtcbiAgICAgICAgcmVzdWx0ID0gY29tcGFyYXRvcih2YWx1ZUEsIHZhbHVlQik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjb21wYXJhdG9yKHZhbHVlQiwgdmFsdWVBKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiBfZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBuZXh0T3JkZXIgPSAoXG4gIGN1cnJlbnRTb3J0Q29sdW1uLFxuICB7IHNvcnRPcmRlciwgc29ydENvbHVtbiB9LFxuICBkZWZhdWx0T3JkZXIgPSBDb25zdC5TT1JUX0RFU0NcbikgPT4ge1xuICBpZiAoIXNvcnRDb2x1bW4gfHwgY3VycmVudFNvcnRDb2x1bW4uZGF0YUZpZWxkICE9PSBzb3J0Q29sdW1uLmRhdGFGaWVsZCkgcmV0dXJuIGRlZmF1bHRPcmRlcjtcbiAgcmV0dXJuIHNvcnRPcmRlciA9PT0gQ29uc3QuU09SVF9ERVNDID8gQ29uc3QuU09SVF9BU0MgOiBDb25zdC5TT1JUX0RFU0M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi9zcmMvc3RvcmUvc29ydC5qcyJdLCJzb3VyY2VSb290IjoiIn0=
//# sourceMappingURL=react-bootstrap-table-next.js.map